<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>W40K Duel – Mockup</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Web fonts (display + UI) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Theme stylesheet (Warhammer-inspired) -->
  <link href="/styles.css" rel="stylesheet">
</head>
<body>
  <!-- Top Banner -->
  <header class="banner py-3 mb-3">
    <div class="container d-flex align-items-center justify-content-between">
      <h1 class="h4 m-0">W40K Duel</h1>
    <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end w-100" style="max-width: 750px;">
  <div class="user-name-BOX_un_ d-none" id="userNameBox">Username: <span id="userName">Anonymous</span></div>
        <div class="username-input-BOX_ui_ input-group input-group-sm" style="max-width: 280px;">
          <input id="usernameInput" type="text" class="form-control bg-dark text-light border-secondary" placeholder="Enter username" aria-label="username">
          <button id="usernameSaveBtn" class="btn btn-warning" type="button">OK</button>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container">
    <!-- Selection controls -->
    <div class="row mb-3 selection-BOX_sel_">
      <div class="col-12 col-md-4 mb-2 mb-md-0">
        <label for="factionSelect" class="form-label">Faction</label>
        <select id="factionSelect" class="form-select"></select>
      </div>
      <div class="col-12 col-md-4 mb-2 mb-md-0">
        <label for="unitSelect" class="form-label">Unit</label>
        <select id="unitSelect" class="form-select" disabled></select>
      </div>
      <div class="col-12 col-md-4">
        <label class="form-label d-block">Weapon Type</label>
        <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap">
          <div class="weapon-type-BOX_wt_ btn-group" role="group" aria-label="Weapon type">
            <input type="radio" class="btn-check" name="weaponType" id="wtRanged" autocomplete="off" checked>
            <label class="btn btn-outline-warning" for="wtRanged">Ranged</label>
            <input type="radio" class="btn-check" name="weaponType" id="wtMelee" autocomplete="off">
            <label class="btn btn-outline-warning" for="wtMelee">Melee</label>
          </div>
          <div class="action-buttons-BOX_ab_ btn-group" role="group" aria-label="Actions">
            <button id="btnFightAI" class="btn btn-outline-warning">Fight AI</button>
            <button id="btnMatchmake" class="btn btn-outline-warning">Matchmake Player</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Weapon Selection (appears after unit selection) -->
    <div class="row mb-3 d-none" id="weaponSelectRow">
      <div class="col-12">
        <div class="stats-box p-3">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Weapon Selection</h2>
            <div class="text-secondary small" id="weaponSelectSummary">—</div>
          </div>
          <div id="weaponSelectBox" class="row g-2"></div>
        </div>
      </div>
    </div>

    <div class="row mb-3">
      <div class="col-12">
        <div class="game-window-BOX_gw_ game-surface p-2 d-none" id="gameWindow">
          <canvas id="gameCanvas" class="w-100" style="display:block; width: 100%; height: auto; aspect-ratio: 16/9; background:#0a0c10;"></canvas>
        </div>
      </div>
    </div>

    <!-- Copyable Fight Log Panel -->
    <div class="row mb-3" id="logRow" style="display:none;">
      <div class="col-12">
        <div class="stats-box p-3">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Fight Log <small class="text-secondary">(Match <code id="matchIdLabel">—</code>)</small></h2>
            <div class="btn-group btn-group-sm" role="group" aria-label="log actions">
              <button id="btnCopyLog" class="btn btn-outline-secondary" type="button">Copy</button>
              <button id="btnDownloadLog" class="btn btn-outline-secondary" type="button">Download .txt</button>
              <button id="btnDownloadJSON" class="btn btn-outline-secondary" type="button">Download JSON</button>
              <button id="btnStopFight" class="btn btn-outline-danger" type="button" title="Stop the current fight">Stop</button>
            </div>
          </div>
          <pre id="textLog" class="mt-2 bg-dark text-light p-2 border border-secondary rounded" style="max-height: 240px; overflow-y: auto; white-space: pre-wrap;">(no log yet)</pre>
        </div>
      </div>
    </div>

  <!-- Lobby Panel (moved above Statistics) -->
  <div class="row mt-3 mb-4">
      <div class="col-12">
        <div class="stats-box p-3" id="lobbyBox">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Lobby</h2>
            
          </div>
          <div id="lobbyList" class="row g-2"></div>
        </div>
      </div>
    </div>

  <!-- Bottom Stats -->
  <div class="row">
      <div class="col-12">
        <div class="stats-BOX_sb_ stats-box p-3" id="statsBox">
          <h2 class="h6 text-warning mb-3">Statistics</h2>
          <div class="row g-3">
            <div class="col-12 col-md-6">
              <div class="card bg-dark border-secondary high-dmg-BOX_hd_">
                <div class="card-body py-3">
                  <div class="text-secondary small">Highest Damage Attack (single volley)</div>
                  <div id="statTopDamageDetails" class="small text-secondary">—</div>
                </div>
              </div>
            </div>
            <div class="col-12 col-md-6">
              <div class="card bg-dark border-secondary saves-BOX_sv_">
                <div class="card-body py-3">
                  <div class="text-secondary small">Best & Worst Save</div>
                  <div class="d-flex gap-4">
                    <div>Best: <span id="statBestSave" class="fw-bold">—</span></div>
                    <div>Worst: <span id="statWorstSave" class="fw-bold">—</span></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
var stats = {};
  // Restore statistics from server (fallback to localStorage)
  async function restoreStatistics() {
  const statTopDamage = null; // removed big number
    const statBestSave = document.getElementById('statBestSave');
    const statWorstSave = document.getElementById('statWorstSave');
    const statTopDamageDetails = document.getElementById('statTopDamageDetails');
    const username = sessionStorage.getItem('username') || 'Anonymous';
    let usedGlobal = false;
  // Try to load today's global max attack first
    try {
      const g = await fetch('/api/stats/max-attack/today').then(r=> r.ok ? r.json() : null).catch(()=>null);
      if (g && g.username && g.weapon) {
    const dmg = g.damage || 0;
    const wnd = g.wounds || 0;
  // big number removed
    if (statTopDamageDetails) statTopDamageDetails.textContent = `${g.username}: ${g.unit} - ${g.weapon} ${dmg} damage (${wnd} wounds)`;
        usedGlobal = true;
      }
    } catch {}
    try {
      const s = await fetch(`/api/stats/get?username=${encodeURIComponent(username)}`).then(r=>r.json());
      stats = s || {};
    } catch {
      stats = JSON.parse(localStorage.getItem('w40kduel_stats') || '{}');
    }
  // big number removed
    if (statBestSave && stats.bestSave !== undefined) statBestSave.textContent = stats.bestSave;
    if (statWorstSave && stats.worstSave !== undefined) statWorstSave.textContent = stats.worstSave;
  if (!usedGlobal && statTopDamageDetails && stats.topDamageDetails !== undefined) statTopDamageDetails.textContent = stats.topDamageDetails;
  // Also fetch biggest per-user attack from server and display if present
    try {
      if (!usedGlobal) {
        const ma = await fetch(`/api/stats/max-attack?username=${encodeURIComponent(username)}`).then(r=>r.json());
        if (ma && ma.username) {
      const dmg = ma.damage || 0;
      const wnd = ma.wounds || 0;
      const det = `${ma.username}: ${ma.unit} - ${ma.weapon} ${dmg} damage (${wnd} wounds)`;
      if (statTopDamageDetails) statTopDamageDetails.textContent = det;
          // big number removed
        }
      }
    } catch {}
    let statsBoxRestore = document.getElementById('statsBox');
    if (statsBoxRestore) statsBoxRestore.classList.remove('d-none');
  }
  restoreStatistics();
  // Demo: set names via query params ?user=... (player removed)
  const params = new URLSearchParams(location.search);

  // Randomize top-bar app name from provided list (new each refresh)
  (function(){
    const names = [
      'Grimdark Slapfight 9000 – because the galaxy needed more petty violence.',
      'Bolter & Banter – competitive shooting and trash talking.',
      'Chainswords at Dawn – the most civilized way to settle things in the 41st millennium.',
      'The Emperor’s Smackdown – sanctioned by His Holy Fist™.',
      'Pew Pew Heresy – for when you’re not quite excommunicate traitoris yet.',
      'Spiky Pauldrons of Destiny – the real source of power in 40K.',
      'Rogal Dorn’s Slap Chop – build it, fortify it, then chop it.',
      'Lasgun Legends: Missing Every Shot Since M2 – accuracy optional.'
    ];
    const chosen = names[Math.floor(Math.random() * names.length)];
    const headerEl = document.querySelector('header.banner h1');
    if (headerEl) headerEl.textContent = chosen;
    // Also set the browser tab title
    try { document.title = chosen; } catch {}
  })();

  const usernameDisplay = document.getElementById('userName');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSaveBtn = document.getElementById('usernameSaveBtn');
  const userNameBoxEl = document.getElementById('userNameBox');
  const usernameInputGroup = document.querySelector('.username-input-BOX_ui_');

    async function setUsername(name){
      const clean = (name || '').trim() || 'Anonymous';
      sessionStorage.setItem('username', clean);
      usernameDisplay.textContent = clean;
      usernameInput.value = clean;
      userNameBoxEl.classList.remove('d-none');
  // Hide the input group once chosen
  if (usernameInputGroup) usernameInputGroup.classList.add('d-none');
      // Join lobby
      try {
        await fetch('/api/lobby/join', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: clean})});
      } catch {}
    }

    // Initialize username: show only if previously chosen in this session
    const stored = sessionStorage.getItem('username');
    if (stored && stored.trim()) {
      setUsername(stored.trim());
    } else {
      const qpUser = params.get('user');
      if (qpUser && qpUser.trim()) {
        // Pre-fill input only; do not consider as chosen until saved
        usernameInput.value = qpUser.trim();
      }
    }

    // Save on click or Enter
    usernameSaveBtn.addEventListener('click', ()=> setUsername(usernameInput.value));
    usernameInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') setUsername(usernameInput.value);
    });

    // Populate factions and units from API
    const factionSelect = document.getElementById('factionSelect');
    const unitSelect = document.getElementById('unitSelect');
    let factions = [];

    async function loadFactions(){
      try {
        const resp = await fetch('/api/factions');
        factions = await resp.json();
        factionSelect.innerHTML = '<option value="">Select Faction</option>' +
          factions.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
      } catch(e){
        factionSelect.innerHTML = '<option value="">(failed to load factions)</option>';
      }
    }

    async function loadUnitsForFaction(fid){
      unitSelect.disabled = true;
      unitSelect.innerHTML = '<option value="">Loading units…</option>';
      if(!fid){ unitSelect.innerHTML = '<option value="">Select unit</option>'; return; }
      try {
    const resp = await fetch(`/api/${encodeURIComponent(fid)}/units`);
        const units = await resp.json();
        unitSelect.innerHTML = '<option value="">Select Unit</option>' +
          units.map(u => {
            const id = u.ID || u.id || u.Name || u.name;
            const name = u.Name || u.name || 'Unit';
            const t = (u.T ?? u.t ?? '–');
            const w = (u.W ?? u.w ?? '–');
      const pts = (u.points || u.Points || '').toString();
      const ptsTxt = pts ? ` — ${pts}pts` : '';
      return `<option value="${id}" data-points="${pts}">${name} (T ${t} / W ${w})${ptsTxt}</option>`;
          }).join('');
        unitSelect.disabled = false;
      } catch(e){
        unitSelect.innerHTML = '<option value="">(failed to load units)</option>';
      }
    }

    factionSelect.addEventListener('change', (e)=>{
      const fid = e.target.value;
      loadUnitsForFaction(fid);
    });

    // Show/update weapon selection when a unit is chosen
    const weaponSelectRow = document.getElementById('weaponSelectRow');
    const weaponSelectBox = document.getElementById('weaponSelectBox');
    const weaponSelectSummary = document.getElementById('weaponSelectSummary');
  const weaponCatalog = { ranged: [], melee: [] };
  const weaponSelection = { ranged: new Set(), melee: null };

    function renderWeaponSelection(){
      if (!weaponSelectBox) return;
      const type = getWeaponType();
      const items = type === 'melee' ? weaponCatalog.melee : weaponCatalog.ranged;
      const isMelee = type === 'melee';
      const selCount = isMelee ? (weaponSelection.melee ? 1 : 0) : weaponSelection.ranged.size;
  const capTxt = isMelee ? 'select 1' : 'select any';
      if (weaponSelectSummary) weaponSelectSummary.textContent = `${type.toUpperCase()} — ${selCount} selected (${capTxt})`;

      // Group weapons by base name (e.g., Plasma Gun) and show modes as radio buttons
      const groupByBase = {};
      items.forEach((w,i)=>{
        // Extract base name and mode
        const m = w.name.match(/^(.*?)(?: \((.*?)\))?$/);
        const base = m ? m[1].trim() : w.name;
        const mode = m && m[2] ? m[2].trim() : 'Standard';
        if (!groupByBase[base]) groupByBase[base] = [];
        groupByBase[base].push({...w, mode, idx: i});
      });
      const controls = Object.entries(groupByBase).map(([base, arr])=>{
        // If only one mode, render as before
        if (arr.length === 1) {
          const w = arr[0];
          const id = `wp_${type}_${w.idx}`;
          const ab = (Array.isArray(w.abilities) && w.abilities.length) ? `[${w.abilities.join(', ')}]` : '';
          const rangeTxt = (w.range && w.range.toLowerCase()!=='melee') ? ` | ${w.range}` : '';
          const descRaw = (w.desc||'').trim().replace(/\s+/g,' ');
          const descTxt = cleanDescriptionAgainstAbilities(descRaw, w.abilities||[]);
          const defaultLabel = w.isStandard ? '<span class="wo-default text-primary ms-2" style="font-weight:600;">(default)</span>' : '';
          const body = `
            <div class="weapon-option">
              <div class="d-flex gap-2 align-items-start">
                <input class="form-check-input mt-1" type="${isMelee?'radio':'checkbox'}" ${isMelee? 'name="meleeWpn"':''} id="${id}" data-name="${encodeURIComponent(w.name)}" ${isMelee ? (weaponSelection.melee===w.name?'checked':'') : (weaponSelection.ranged.has(w.name)?'checked':'')}>
                <label class="form-check-label w-100" for="${id}">
                  <div class="wo-name">${w.name} ${ab? `<span class="wo-abilities">${ab}</span>`:''} ${defaultLabel}</div>
                  <div class="wo-stats">A ${w.attacks} | Skill ${w.skill}+ | S ${w.strength} | AP ${w.ap} | D ${w.damage}${rangeTxt}</div>
                  ${descTxt ? `<div class="wo-desc">${descTxt}</div>`:''}
                </label>
              </div>
            </div>`;
          return `<div class="col-12 col-md-6">${body}</div>`;
        }
        // Multiple modes: render radio group
        const radioName = `wpgrp_${type}_${base.replace(/\W/g,'_')}`;
        const radios = arr.map(w=>{
          const id = `wp_${type}_${w.idx}`;
          const ab = (Array.isArray(w.abilities) && w.abilities.length) ? `[${w.abilities.join(', ')}]` : '';
          const rangeTxt = (w.range && w.range.toLowerCase()!=='melee') ? ` | ${w.range}` : '';
          const descRaw = (w.desc||'').trim().replace(/\s+/g,' ');
          const descTxt = cleanDescriptionAgainstAbilities(descRaw, w.abilities||[]);
          const defaultLabel = w.isStandard && w.mode==='Standard' ? '<span class="wo-default text-primary ms-2" style="font-weight:600;">(default)</span>' : '';
          const checked = isMelee ? (weaponSelection.melee===w.name?'checked':'') : (weaponSelection.ranged.has(w.name)?'checked':'');
          return `<div class="weapon-option">
            <div class="d-flex gap-2 align-items-start">
              <input class="form-check-input mt-1" type="radio" name="${radioName}" id="${id}" data-name="${encodeURIComponent(w.name)}" ${checked}>
              <label class="form-check-label w-100" for="${id}">
                <div class="wo-name">${base} <span class="wo-mode text-info ms-1">(${w.mode})</span> ${ab? `<span class="wo-abilities">${ab}</span>`:''} ${defaultLabel}</div>
                <div class="wo-stats">A ${w.attacks} | Skill ${w.skill}+ | S ${w.strength} | AP ${w.ap} | D ${w.damage}${rangeTxt}</div>
                ${descTxt ? `<div class="wo-desc">${descTxt}</div>`:''}
              </label>
            </div>
          </div>`;
        }).join('');
        return `<div class="col-12 col-md-6"><div class="wo-group">${radios}</div></div>`;
      }).join('');
      weaponSelectBox.innerHTML = controls || '<div class="col-12 text-secondary">No weapons found for this type.</div>';

      // Bind change handlers
      const inputs = weaponSelectBox.querySelectorAll('input.form-check-input');
      inputs.forEach(inp => {
        inp.addEventListener('change', (ev)=>{
          const nm = decodeURIComponent(ev.target.getAttribute('data-name')||'');
          if (!nm) return;
          // Find base name for grouping
          const label = inp.closest('.wo-group')?.querySelector('.wo-name')?.textContent || inp.closest('.weapon-option')?.querySelector('.wo-name')?.textContent || '';
          const baseMatch = label.match(/^(.*?)(?:\s*\(|$)/);
          const base = baseMatch ? baseMatch[1].trim() : nm;
          if (isMelee) {
            weaponSelection.melee = nm;
          } else {
            // Remove all modes of this base from selection
            Object.keys(groupByBase).forEach(b=>{
              if (b===base) {
                groupByBase[b].forEach(w=> weaponSelection.ranged.delete(w.name));
              }
            });
            weaponSelection.ranged.add(nm);
          }
          renderWeaponSelection();
        });
      });
    }

    async function populateWeaponSelection(fid, uid){
      if (!fid || !uid) { if (weaponSelectRow) weaponSelectRow.classList.add('d-none'); return; }
      try {
        const [all, options] = await Promise.all([
          pickAnyWeapons(fid, uid),
          fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/options`).then(r=>r.json()).catch(()=>[])
        ]);
        // Compute default flags from options: keep bases default, mark replacements/add-ons non-default
        const computeDefaultFlags = (weps, opts)=>{
          const norm = (s)=> String(s||'').toLowerCase().replace(/[–—]/g,'-').replace(/\s+/g,' ').trim();
          const baseNameOf = (n)=> norm(String(n||'').split(/\s[–—-]\s/)[0]);
          const pluralize = (b)=> b.endsWith('s') ? b : `${b}s`;
          const text = norm((Array.isArray(opts)? opts:[]).map(o=> (o.description||o.Description||'')).join(' \n '));
          const names = weps.map(w=> w.name);
          const bases = names.map(n=> baseNameOf(n));
          const plurals = bases.map(b=> pluralize(b));
          const flags = new Map(names.map(n=> [n, true]));
          // Replacement phrases: "replace(d) ... with ..." — bases stay default, replacements become non-default
          const replRe = /(replace(?:d)?)[\s\S]*? with [\s\S]*?(?:\.|\n|$)/g;
          let m;
          while ((m = replRe.exec(text))){
            const seg = m[0];
            const wi = seg.indexOf(' with ');
            if (wi < 0) continue;
            const left = seg.slice(0, wi);
            const right = seg.slice(wi + 6);
            for (let i=0;i<names.length;i++){
              const b = bases[i]; const p = plurals[i];
              if (left.includes(b) || left.includes(p)) flags.set(names[i], true);
              if (right.includes(b) || right.includes(p)) flags.set(names[i], false);
            }
          }
          // Equipment additions: mark those as non-default
          const equipRe = /(equipped with|can be equipped with|can be equipped|can be given)[\s\S]*?(?:\.|\n|$)/g;
          while ((m = equipRe.exec(text))){
            const seg = m[0];
            for (let i=0;i<names.length;i++){
              const b = bases[i]; const p = plurals[i];
              if (seg.includes(b) || seg.includes(p)) flags.set(names[i], false);
            }
          }
          return flags;
        };
        const flags = computeDefaultFlags(all, options);
        all.forEach(w => { w.isStandard = !!flags.get(w.name); });
        weaponCatalog.ranged = all.filter(w=> w.type==='ranged');
        weaponCatalog.melee = all.filter(w=> w.type==='melee');
        // Pre-check standard weapons
        weaponSelection.ranged = new Set(weaponCatalog.ranged.filter(w=>w.isStandard).map(w=>w.name));
        weaponSelection.melee = weaponCatalog.melee.find(w=>w.isStandard)?.name || null;
        if (weaponSelectRow) weaponSelectRow.classList.remove('d-none');
        renderWeaponSelection();
      } catch {
        if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
      }
    }

    unitSelect.addEventListener('change', (e)=>{
      const fid = factionSelect.value;
      const uid = e.target.value;
      populateWeaponSelection(fid, uid);
    });

    document.getElementById('wtRanged').addEventListener('change', ()=> renderWeaponSelection());
    document.getElementById('wtMelee').addEventListener('change', ()=> renderWeaponSelection());

    // Read selected weapon type
    function getWeaponType(){
      return document.getElementById('wtMelee').checked ? 'melee' : 'ranged';
    }

    // Expose current selection (for future game integration)
  window.currentSelection = () => ({
      user: sessionStorage.getItem('username') || 'Anonymous',
      factionId: factionSelect.value,
      unitId: unitSelect.value,
      weaponType: getWeaponType()
    });

    // Init
    loadFactions();
    // Canvas helpers
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));
    const gameWindowEl = document.getElementById('gameWindow');
    let hasFightStarted = false;
    function showFightSurface(){ gameWindowEl?.classList.remove('d-none'); }
    function hideFightSurface(){ if (!hasFightStarted) gameWindowEl?.classList.add('d-none'); }
    // Text log helpers
    const logRow = document.getElementById('logRow');
    const textLogEl = document.getElementById('textLog');
    const matchIdLabel = document.getElementById('matchIdLabel');
    function showLogRow(){ if (logRow) logRow.style.display = ''; }
    const TEXT_LOG_LIMIT = 600; // keep last N lines for responsiveness
    function setTextLog(lines){
      if (!textLogEl) return;
      let arr = Array.isArray(lines) ? lines.slice(-TEXT_LOG_LIMIT) : String(lines||'').split('\n');
      const txt = arr.join('\n');
      textLogEl.textContent = txt;
      // autoscroll to bottom
      textLogEl.scrollTop = textLogEl.scrollHeight;
    }
    function clearTextLog(){ setTextLog(''); }
    async function copyTextLog(){
      try { await navigator.clipboard.writeText(textLogEl?.textContent || ''); } catch {}
    }
    function download(filename, content, mime='text/plain'){
      const blob = new Blob([content], {type: mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 500);
    }
    async function downloadJSONLog(matchId){
      if (!matchId) return;
      try {
        const resp = await fetch(`/api/match/${encodeURIComponent(matchId)}`);
        if (!resp.ok) throw new Error('not found');
        const data = await resp.json();
        download(`match_${matchId}.json`, JSON.stringify(data, null, 2), 'application/json');
      } catch {}
    }
    function resizeCanvas(){
      // match displayed size
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.max(320, Math.floor(rect.width));
      const height = Math.max(180, Math.floor(rect.width * 9/16));
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawSplash();
    }
    function drawSplash(){
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      ctx.fillStyle = '#0b1016';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#c9a753';
      ctx.font = '16px system-ui, sans-serif';
      ctx.fillText('Shooting Duel — ready', 12, 24);
      ctx.fillStyle = '#8aa0b8';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText('Pick a faction/unit and press Fight AI', 12, 44);
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 0);
  // Hide canvas by default until a fight starts
  hideFightSurface();

    // Data helpers
    const numFrom = (s)=>{
      if (!s) return 0; const m = String(s).match(/\d+/); return m? parseInt(m[0],10):0;
    };
    async function getUnitStats(fid, uid){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/models`);
      const models = await resp.json();
      const m = models && models[0] ? models[0] : {};
      const T = numFrom(m.T) || 4;
      const W = numFrom(m.W) || 5;
      const Sv = numFrom(m.Sv) || 7;
      const InvSv = numFrom(m.inv_sv) || numFrom(m.InvSv) || 0;
      return { T, W, Sv, InvSv };
    }

    async function getUnitDetail(fid, uid){
      // unit basic
      let name = 'Unit';
      let points = null;
      try {
        const u = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}`).then(r=>r.json());
        name = u.name || u.Name || name;
        const p = (u.points ?? u.Points);
        if (p !== undefined && p !== null && String(p).trim() !== '') {
          const n = parseInt(String(p), 10);
          if (!isNaN(n)) points = n;
        }
      } catch {}
      if (name === 'Unit') {
        const opt = Array.from(unitSelect.options).find(o=> o.value==uid);
        if (opt) name = opt.textContent.replace(/\s*\(T .*?\)\s*$/, '').trim() || name;
      }
      // points fallback from the selected option (works for the player's unit)
      if (points === null) {
        const opt = Array.from(unitSelect.options).find(o=> o.value==uid);
        if (opt) {
          const pv = opt.getAttribute('data-points') || '';
          const n = parseInt(pv, 10);
          if (!isNaN(n)) points = n;
        }
      }
      // stats
      const stats = await getUnitStats(fid, uid);
      // abilities
      let abilities = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/abilities`).then(r=>r.json());
        abilities = Array.isArray(list) ? list.map(a=> a.name || a.Name).filter(Boolean) : [];
      } catch {}
      // keywords
      let keywords = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/keywords`).then(r=>r.json());
        keywords = Array.isArray(list) ? list.map(k=> k.keyword || k.Keyword).filter(Boolean) : [];
      } catch {}
      // weapons: include stats for display as text
      let melee = [], ranged = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`).then(r=>r.json());
        (Array.isArray(list) ? list : []).forEach(w=>{
          const item = {
            name: w.name || w.Name,
            desc: (w.description || w.Description || '').toString(),
            attacks: (w.attacks || w.Attacks || '').toString(),
            skill: (w.bs_ws || w.BSOrWS || '').toString(),
            strength: (w.strength || w.Strength || '').toString(),
            ap: (w.ap || w.AP || '').toString(),
            damage: (w.damage || w.Damage || '').toString(),
          };
          if (String(w.range).toLowerCase()==='melee') melee.push(item); else ranged.push(item);
        });
      } catch {}
  return { name, points, stats, abilities, keywords, weapons: { melee, ranged } };
    }
    // Extract common weapon abilities from description
    function parseWeaponAbilities(desc){
      const d = String(desc||'').toLowerCase();
      const out = [];
      if (/torrent/.test(d)) out.push('Torrent');
      // Sustained Hits N (any number)
      const sh = d.match(/sustained\s*hits\s*(\d+)/);
      if (sh) out.push(`Sustained Hits ${sh[1]}`);
      if (/lethal\s*hits/.test(d)) out.push('Lethal Hits');
      if (/twin[-\s]?linked/.test(d)) out.push('Twin-linked');
      if (/devastating\s*wounds/.test(d)) out.push('Devastating Wounds');
      if (/heavy/.test(d)) out.push('Heavy');
      if (/blast/.test(d)) out.push('Blast');
      if (/indirect\s*fire/.test(d)) out.push('Indirect Fire');
      if (/ignores\s*cover/.test(d)) out.push('Ignores Cover');
      if (/assault/.test(d)) out.push('Assault');
      if (/pistol/.test(d)) out.push('Pistol');
      const rf = d.match(/rapid\s*fire\s*(\d+)/);
      if (rf) out.push(`Rapid Fire ${rf[1]}`); else if (/rapid\s*fire/.test(d)) out.push('Rapid Fire');
      const mel = d.match(/melta\s*(\d+)/);
      if (mel) out.push(`Melta ${mel[1]}`); else if (/melta/.test(d)) out.push('Melta');
      if (/grenade/.test(d)) out.push('Grenade');
      if (/hazardous/.test(d)) out.push('Hazardous');
      // Anti-<Type> X+
      const antiRe = /anti-([a-z \-]+)\s*(\d)\+/g;
      let m;
      while ((m = antiRe.exec(d)) !== null) {
        const kw = (m[1]||'').trim().replace(/\s+/g,' ');
        const tn = m[2];
        if (kw && tn) out.push(`Anti-${kw} ${tn}+`);
      }
      return out;
    }
    // Remove description tokens that duplicate abilities already shown in brackets
    function cleanDescriptionAgainstAbilities(desc, abilities){
      const raw = String(desc||'');
      if (!raw.trim()) return '';
      const normalize = (s)=> s.toLowerCase()
        .replace(/[+]/g,'')
        .replace(/[^a-z0-9 \-]/g,'')
        .replace(/\s+/g,' ')
        .trim();
      const abilSet = new Set((abilities||[]).map(a=>{
        const n = normalize(a);
        if (n.startsWith('sustained hits')) return 'sustained hits';
        if (n.startsWith('rapid fire')) return 'rapid fire';
        if (n.startsWith('melta')) return 'melta';
        if (n.startsWith('anti-') || n.startsWith('anti ')) return 'anti';
        if (n === 'twin-linked') return 'twin linked';
        return n;
      }));
      const parts = raw.split(/[;,]/).map(t=> t.trim()).filter(Boolean);
      const kept = parts.filter(t=>{
        const n = normalize(t);
        if (!n) return false;
        if (abilSet.has(n)) return false;
        if (n.startsWith('anti') && abilSet.has('anti')) return false;
        if ((n === 'twin linked' || n === 'twin-linked') && (abilSet.has('twin linked'))) return false;
        if (n.startsWith('sustained hits') && abilSet.has('sustained hits')) return false;
        if (n.startsWith('rapid fire') && abilSet.has('rapid fire')) return false;
        if (n.startsWith('melta') && abilSet.has('melta')) return false;
        return true;
      });
      return kept.join(', ');
    }
  // (no-op placeholder removed)
    async function pickWeapons(fid, uid, type){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`);
  const weapons = await resp.json();
  const arr = Array.isArray(weapons) ? weapons : [];
  const isMelee = type === 'melee';
  // Range=='Melee' denotes melee; others are ranged
  const filtered = arr.filter(w => isMelee ? String(w.range).toLowerCase()==='melee' : String(w.range).toLowerCase()!=='melee');
      if (!filtered.length) throw new Error('No weapons of selected type');
      return filtered.map(w => {
        const skill = numFrom(w.bs_ws || w.BSOrWS) || 4;
        const S = numFrom(w.strength || w.Strength) || 4;
        const AP = parseInt(String(w.ap || w.AP || '0'),10) || 0;
        const attacks = String(w.attacks || w.Attacks || '1');
        const damage = String(w.damage || w.Damage || '1');
        const desc = (w.description || w.Description || '').toString();
        const abilities = parseWeaponAbilities(desc);
        const range = String(w.range || w.Range || '').toString();
        return { name: w.name || w.Name, type: isMelee ? 'melee' : 'ranged', range, attacks, skill, strength: S, ap: AP, damage, desc, abilities };
      });
    }

    async function pickAnyWeapons(fid, uid){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`);
  const weapons = await resp.json();
  const arr = Array.isArray(weapons) ? weapons : [];
  return arr.map(w => {
        const isMelee = String(w.range).toLowerCase()==='melee';
        const skill = numFrom(w.bs_ws || w.BSOrWS) || 4;
        const S = numFrom(w.strength || w.Strength) || 4;
        const AP = parseInt(String(w.ap || w.AP || '0'),10) || 0;
        const attacks = String(w.attacks || w.Attacks || '1');
        const damage = String(w.damage || w.Damage || '1');
        const desc = (w.description || w.Description || '').toString();
        const abilities = parseWeaponAbilities(desc);
        const range = String(w.range || w.Range || '').toString();
        return { name: w.name || w.Name, type: isMelee ? 'melee' : 'ranged', range, attacks, skill, strength: S, ap: AP, damage, desc, abilities };
      });
    }

    async function pickWeaponsSafe(fid, uid, preferredType){
      try {
        return await pickWeapons(fid, uid, preferredType);
      } catch {
        try {
          const opposite = preferredType === 'melee' ? 'ranged' : 'melee';
          return await pickWeapons(fid, uid, opposite);
        } catch {
          return await pickAnyWeapons(fid, uid);
        }
      }
    }

    // Fairer AI opponent selection by points across all factions
    async function pickFairOpponentByPoints(myPts){
      if (!myPts || isNaN(myPts) || myPts <= 0) return null;
      // Ensure we have a factions list
      let facs = Array.isArray(factions) && factions.length ? factions : [];
      if (!facs.length) {
        try { facs = await fetch('/api/factions').then(r=>r.json()); } catch { facs = []; }
      }
      if (!facs.length) return null;
      // Fetch units for all factions in parallel
      const settled = await Promise.allSettled(facs.map(f=> {
        const fid = f.id || f.ID;
        return fetch(`/api/${encodeURIComponent(fid)}/units`).then(r=>r.json()).then(list=>({ fid, list }));
      }));
      const entries = [];
      for (const s of settled) {
        if (s.status === 'fulfilled' && s.value && Array.isArray(s.value.list)) {
          const fid = s.value.fid;
          for (const u of s.value.list) {
            const p = parseInt(String(u.points||u.Points||''), 10);
            if (!isNaN(p) && p > 0) entries.push({ fid, unit: u, pts: p });
          }
        }
      }
      if (!entries.length) return null;
      // Try tightening bands and enforce min ratio to avoid heavy mismatches
      const bands = [0.10, 0.15, 0.20, 0.25];
      const minRatio = 0.75; // don't go below 75% of player's points
      const pickFrom = (arr)=>{
        // Sort by absolute distance, then pick among top 3 randomly for variety
        const sorted = arr.slice().sort((a,b)=> Math.abs(a.pts - myPts) - Math.abs(b.pts - myPts));
        const top = sorted.slice(0, Math.min(3, sorted.length));
        return top[Math.floor(Math.random()*top.length)];
      };
      for (const b of bands) {
        let lo = Math.floor(myPts*(1-b));
        const hi = Math.ceil(myPts*(1+b));
        const minLo = Math.floor(myPts*minRatio);
        lo = Math.max(lo, minLo);
        const cands = entries.filter(e => e.pts >= lo && e.pts <= hi);
        if (cands.length) return pickFrom(cands);
      }
      // If still none, pick nearest within broader reasonable bounds
      const broader = entries.filter(e => e.pts >= Math.floor(myPts*minRatio) && e.pts <= Math.ceil(myPts*1.35));
      if (broader.length) return pickFrom(broader);
      // Fallback: absolute nearest overall
      return pickFrom(entries);
    }

  function drawFightPhase(leftDetail, rightDetail, leftW, leftWMax, rightW, rightWMax, res, title='Combat', winnerText=null, nowCtx=null){
      resizeCanvas();
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      ctx.fillStyle = '#0b1016';
      ctx.fillRect(0,0,w,h);
      // Title
      ctx.fillStyle = '#c9a753'; ctx.font='16px system-ui,sans-serif';
      ctx.fillText(title, 12, 22);
      const pad = 12;
      // Columns: left 30%, middle 40%, right 30%
      const colW = [Math.floor((w - pad*4)*0.3), Math.floor((w - pad*4)*0.4), Math.floor((w - pad*4)*0.3)];
      const x0 = pad, x1 = x0 + colW[0] + pad, x2 = x1 + colW[1] + pad;
      const top = 40, boxH = h - top - pad;
      // Panels
      ctx.fillStyle = '#11161f';
      ctx.fillRect(x0, top, colW[0], boxH);
      ctx.fillRect(x1, top, colW[1], boxH);
      ctx.fillRect(x2, top, colW[2], boxH);
  // Left unit
      ctx.fillStyle = '#e5e7eb'; ctx.font='14px system-ui,sans-serif';
  const leftName = leftDetail?.name || 'Player';
  const rightName = rightDetail?.name || 'Opponent';
  const leftPts = (()=>{ const p = leftDetail?.points; return (typeof p === 'number' && p > 0) ? p : null; })();
  const rightPts = (()=>{ const p = rightDetail?.points; return (typeof p === 'number' && p > 0) ? p : null; })();
  const leftLabel = `Player: ${leftName}${leftPts? ` — ${leftPts}pts` : ''}`;
  ctx.fillText(leftLabel, x0+8, top+22);
  // Left wounds bar
  let barX = x0+8, barY = top+34, barW = colW[0]-16, barH = 14;
  ctx.fillStyle = '#243042'; ctx.fillRect(barX, barY, barW, barH);
  let frac = Math.max(0, Math.min(1, (leftW||0)/(leftWMax||1)));
  ctx.fillStyle = frac>0.5? '#2ecc71' : frac>0.25? '#f1c40f' : '#e74c3c';
  ctx.fillRect(barX, barY, Math.floor(barW*frac), barH);
  ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
  ctx.fillText(`Wounds: ${leftW}/${leftWMax}`, x0+8, barY+barH+18);
      // Add extra space before stats
      let y = barY+barH+38;
      // Responsive font sizes for mobile
      if (typeof isMobile === 'undefined') {
        var isMobile = window.innerWidth < 600;
      }
      ctx.font = isMobile ? '13px system-ui,sans-serif' : '14px system-ui,sans-serif';
  // Declare ls, lwa, lwr, lwm, usedLeft
  const ls = leftDetail?.stats || {};
  const lwa = leftDetail?.abilities || [];
  const lwr = leftDetail?.weapons?.ranged || [];
  const lwm = leftDetail?.weapons?.melee || [];
  const usedLeft = nowCtx?.usedLeft;
  ctx.fillStyle = '#c9a753'; ctx.font='12px system-ui,sans-serif';
  ctx.fillText(`Stats: T ${ls.T||'-'}  Sv ${ls.Sv? ls.Sv+'+':'-'}  Inv ${ls.InvSv? ls.InvSv+'+':'-'}`, x0+8, y); y+=18;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Abilities:', x0+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const lAbTxt = (lwa && lwa.length) ? `[${lwa.slice(0,4).join(', ')}]` : '[]';
  ctx.fillText(lAbTxt, x0+12, y); y+=16;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Weapons:', x0+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const lwlist = (Array.isArray(usedLeft) ? usedLeft : [...lwr, ...lwm]).slice(0,4);
      lwlist.forEach(wi=>{
        const nm = (wi.name||'Weapon');
        const statsTxt = `A ${wi.attacks||'?'} | Skill ${wi.skill||'?'} | S ${wi.strength||'?'} | AP ${wi.ap||'?'} | D ${wi.damage||'?'}`;
        const rawDesc = (wi.desc||'').replace(/\s+/g,' ');
        const wAbilities = Array.isArray(wi.abilities) ? wi.abilities : parseWeaponAbilities(wi.desc||'');
        const desc = cleanDescriptionAgainstAbilities(rawDesc, wAbilities).slice(0,40);
        // Weapon name and stats
        const base = `• ${nm} — ${statsTxt}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(base, x0+12, y);
        y += 16;
        // Abilities row (gold)
        if (wAbilities.length) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(`[${wAbilities.join(', ')}]`, x0+20, y);
          y += 16;
        }
        // Description row (bluish)
        if (desc) {
          ctx.fillStyle = '#8aa0b8';
          ctx.fillText(`  ${desc}`, x0+20, y);
          y += 16;
        }
      });
  // Right unit
      ctx.fillStyle = '#e5e7eb'; ctx.font='14px system-ui,sans-serif';
  const rightLabel = `Opponent: ${rightName}${rightPts? ` — ${rightPts}pts` : ''}`;
  ctx.fillText(rightLabel, x2+8, top+22);
  barX = x2+8; barY = top+34; barW = colW[2]-16; barH = 14;
  ctx.fillStyle = '#243042'; ctx.fillRect(barX, barY, barW, barH);
  frac = Math.max(0, Math.min(1, (rightW||0)/(rightWMax||1)));
  ctx.fillStyle = frac>0.5? '#2ecc71' : frac>0.25? '#f1c40f' : '#e74c3c';
  ctx.fillRect(barX, barY, Math.floor(barW*frac), barH);
  ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
  ctx.fillText(`Wounds: ${rightW}/${rightWMax}`, x2+8, barY+barH+18);
      // Add extra space before stats
      y = barY+barH+38;
      // Responsive font sizes for mobile
      if (typeof isMobile === 'undefined') {
        var isMobile = window.innerWidth < 600;
      }
      ctx.font = isMobile ? '13px system-ui,sans-serif' : '14px system-ui,sans-serif';
  // Declare rs, rwa, rwr, rwm, usedRight
  const rs = rightDetail?.stats || {};
  const rwa = rightDetail?.abilities || [];
  const rwr = rightDetail?.weapons?.ranged || [];
  const rwm = rightDetail?.weapons?.melee || [];
  const usedRight = nowCtx?.usedRight;
  ctx.fillStyle = '#c9a753'; ctx.font='12px system-ui,sans-serif';
  ctx.fillText(`Stats: T ${rs.T||'-'}  Sv ${rs.Sv? rs.Sv+'+':'-'}  Inv ${rs.InvSv? rs.InvSv+'+':'-'}`, x2+8, y); y+=18;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Abilities:', x2+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const rAbTxt = (rwa && rwa.length) ? `[${rwa.slice(0,4).join(', ')}]` : '[]';
  ctx.fillText(rAbTxt, x2+12, y); y+=16;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Weapons:', x2+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const rwlist = (Array.isArray(usedRight) ? usedRight : [...rwr, ...rwm]).slice(0,4);
      rwlist.forEach(wi=>{
        const nm = (wi.name||'Weapon');
        const statsTxt = `A ${wi.attacks||'?'} | Skill ${wi.skill||'?'} | S ${wi.strength||'?'} | AP ${wi.ap||'?'} | D ${wi.damage||'?'}`;
        const rawDesc = (wi.desc||'').replace(/\s+/g,' ');
        const wAbilities = Array.isArray(wi.abilities) ? wi.abilities : parseWeaponAbilities(wi.desc||'');
        const desc = cleanDescriptionAgainstAbilities(rawDesc, wAbilities).slice(0,40);
        // Weapon name and stats
        const base = `• ${nm} — ${statsTxt}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(base, x2+12, y);
        y += 16;
        // Abilities row (gold)
        if (wAbilities.length) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(`[${wAbilities.join(', ')}]`, x2+20, y);
          y += 16;
        }
        // Description row (bluish)
        if (desc) {
          ctx.fillStyle = '#8aa0b8';
          ctx.fillText(`  ${desc}`, x2+20, y);
          y += 16;
        }
      });
      // Middle: combat summary (no log spam)
      const resObj = res || {};
      const sp = resObj.subphases || resObj.Subphases || {};
      const tnHit = (sp.hits?.target) ?? (sp.Hits?.Target) ?? null;
      const tnWnd = (sp.wounds?.target) ?? (sp.Wounds?.Target) ?? null;
      const tnSv  = (sp.saves?.target) ?? (sp.Saves?.Target) ?? null;
      const nowA = nowCtx?.attacker || '';
      const nowW = nowCtx?.weaponName || '';
      const nowD = nowCtx?.defender || '';
      const ab  = Array.isArray(nowCtx?.weaponAbilities) && nowCtx.weaponAbilities.length ? ` [${nowCtx.weaponAbilities.join(', ')}]` : '';
      ctx.fillStyle = '#c9a753'; ctx.font='14px system-ui,sans-serif';
      ctx.fillText('Combat', x1+8, top+22);
      ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
      let yMid = top+44;
      if (nowA || nowW || nowD) {
        const pre = `Now: ${nowA || '—'} uses ${nowW || '—'}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(pre, x1+8, yMid);
        let xPos = x1+8 + ctx.measureText(pre).width;
        if (ab) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(` ${ab}`, xPos, yMid);
          xPos += ctx.measureText(` ${ab}`).width;
        }
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(` vs ${nowD || '—'}`, xPos, yMid);
        yMid += 20;
      }
      if (tnHit || tnWnd || tnSv) {
        const svTxt = (tnSv && tnSv !== 7) ? `${tnSv}+` : (tnSv===7 ? '—' : '');
        const tnLine = `To Hit ${tnHit? tnHit+'+':'?'}, To Wound ${tnWnd? tnWnd+'+':'?'}, Save ${svTxt||'?'}`;
        ctx.fillText(tnLine, x1+8, yMid); yMid += 20;
      }
      const stats = [
        `Attacks: ${resObj.attacks||resObj.Attacks||0}`,
        `Hits: ${resObj.hits||resObj.Hits||0}`,
        `Wounds: ${resObj.wounds||resObj.Wounds||0}`,
        `Saved: ${resObj.saved||resObj.Saved||0}`,
        `Unsaved: ${resObj.unsaved||resObj.Unsaved||0}`,
        `Damage: ${resObj.damage_total||resObj.DamageTotal||0}`,
      ];
      stats.forEach((t,i)=> ctx.fillText(t, x1+8, yMid + i*18));
      // Winner overlay
      if (winnerText) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0,w,h);
        ctx.fillStyle = '#c9a753';
        ctx.font = 'bold 22px system-ui,sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(winnerText, Math.floor(w/2), Math.floor(h/2));
        ctx.restore();
      }
    }
    // Lobby polling
    async function refreshLobby(){
      try {
        const resp = await fetch('/api/lobby');
        const list = await resp.json();
        const wrap = document.getElementById('lobbyList');
        wrap.innerHTML = list.map(e => `
          <div class="col-12 col-md-6 col-lg-4">
            <div class="card bg-dark border-secondary">
              <div class="card-body py-2 d-flex justify-content-between">
                <span class="fw-semibold">${e.name}</span>
                <span class="badge text-bg-secondary">${e.phase || 'idle'}</span>
              </div>
            </div>
          </div>`).join('');
      } catch {}
    }
    refreshLobby();
    setInterval(refreshLobby, 3000);

    // Action buttons handlers (placeholder wiring)
    function ensureSelection(){
      const sel = window.currentSelection();
      if (!sel.user || sel.user === 'Anonymous') {
        alert('Please choose a username first.');
        return null;
      }
      if (!sel.factionId) { alert('Please select a faction.'); return null; }
      if (!sel.unitId) { alert('Please select a unit.'); return null; }
      return sel;
    }
    const selectionRow = document.querySelector('.selection-BOX_sel_');
    const statsBox = document.getElementById('statsBox');
    function hidePreMatchUI(){
      if (selectionRow) selectionRow.classList.add('d-none');
      if (statsBox) statsBox.classList.add('d-none');
    }
    function showPostMatchUI(){
  if (selectionRow) selectionRow.classList.remove('d-none');
  if (statsBox) statsBox.classList.remove('d-none');
  // Show weapon selection after fight
  if (weaponSelectRow) weaponSelectRow.classList.remove('d-none');
    }
  document.getElementById('btnFightAI').addEventListener('click', async ()=>{
      const sel = ensureSelection();
      if (!sel) return;
      console.log('Fight AI with selection:', sel);
  hidePreMatchUI();
  hasFightStarted = true;
  showFightSurface();
  // Hide weapon selection during fight
  if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
      fetch('/api/lobby/phase', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: sel.user, phase: 'vs-ai'})}).catch(()=>{});
  try {
  const [detail] = await Promise.all([
          getUnitDetail(sel.factionId, sel.unitId)
        ]);
        // Build weapon list from selection with fallback
        let weps = [];
        if (sel.weaponType === 'ranged') {
          if (weaponSelection.ranged.size > 0) {
            // Respect selection order: map selected names -> weapon objects
            const names = Array.from(weaponSelection.ranged);
            const byName = new Map(weaponCatalog.ranged.map(w=> [w.name, w]));
            weps = names.map(n=> byName.get(n)).filter(Boolean);
          } else {
            weps = await pickWeapons(sel.factionId, sel.unitId, sel.weaponType);
          }
        } else {
          if (weaponSelection.melee) {
            const m = weaponCatalog.melee.find(w=> w.name === weaponSelection.melee);
            weps = m ? [m] : [];
          }
          if (weps.length === 0) {
            weps = await pickWeapons(sel.factionId, sel.unitId, sel.weaponType);
          }
        }
  // Make sure detail.name remains the unit name; we’ll use sel.user separately
        // Pick fair AI opponent by points across all factions
        const myPts = (()=>{
          const opt = Array.from(unitSelect.options).find(o=> o.value===sel.unitId);
          const v = opt?.getAttribute('data-points') || '';
          const n = parseInt(v,10); return isNaN(n)? null : n;
        })();
        let oppFactionId = sel.factionId;
        let oppUnit = null;
        if (myPts && myPts > 0) {
          const pick = await pickFairOpponentByPoints(myPts);
          if (pick) { oppFactionId = pick.fid; oppUnit = pick.unit; }
        }
        if (!oppUnit) {
          // Fallback: player faction, pick a random unit
          try {
            const oppUnits = await fetch(`/api/${encodeURIComponent(sel.factionId)}/units`).then(r=>r.json());
            if (Array.isArray(oppUnits) && oppUnits.length) {
              oppUnit = oppUnits[Math.floor(Math.random()*oppUnits.length)];
            }
          } catch {}
        }
        const oppUnitId = oppUnit ? (oppUnit.id||oppUnit.ID) : sel.unitId;
        const oppDetail = await getUnitDetail(oppFactionId, oppUnitId);
        // If API detail didn't include points, try to use the selected oppUnit's points
        if (oppDetail && (oppDetail.points == null || Number.isNaN(oppDetail.points))) {
          const rawP = (oppUnit && (oppUnit.points || oppUnit.Points)) || '';
          const np = parseInt(String(rawP), 10);
          if (!Number.isNaN(np)) oppDetail.points = np;
        }
        // Pre-pick opponent weapons: always use default wargear
        const oppAllWeapons = await pickAnyWeapons(oppFactionId, oppUnitId);
        const baseName = (n)=> String(n||'').split(/\s[–—-]\s/)[0].trim();
        const uniqByBase = (arr)=>{
          const seen = new Set(); const out = [];
          for (const w of arr) { const b = baseName(w.name); if (!seen.has(b)) { seen.add(b); out.push(w); } }
          return out;
        };
        // Mark default wargear for opponent using its replacement options (same logic as player)
        try {
          const oppOptions = await fetch(`/api/${encodeURIComponent(oppFactionId)}/${encodeURIComponent(oppUnitId)}/options`).then(r=>r.json()).catch(()=>[]);
          // Reuse the same default computation for AI
          const computeDefaultFlagsAI = (weps, opts)=>{
            const norm = (s)=> String(s||'').toLowerCase().replace(/[–—]/g,'-').replace(/\s+/g,' ').trim();
            const baseNameOf = (n)=> norm(String(n||'').split(/\s[–—-]\s/)[0]);
            const pluralize = (b)=> b.endsWith('s') ? b : `${b}s`;
            const text = norm((Array.isArray(opts)? opts:[]).map(o=> (o.description||o.Description||'')).join(' \n '));
            const names = weps.map(w=> w.name);
            const bases = names.map(n=> baseNameOf(n));
            const plurals = bases.map(b=> pluralize(b));
            const flags = new Map(names.map(n=> [n, true]));
            const replRe = /(replace(?:d)?)[\s\S]*? with [\s\S]*?(?:\.|\n|$)/g;
            let m;
            while ((m = replRe.exec(text))){
              const seg = m[0];
              const wi = seg.indexOf(' with ');
              if (wi < 0) continue;
              const left = seg.slice(0, wi);
              const right = seg.slice(wi + 6);
              for (let i=0;i<names.length;i++){
                const b = bases[i]; const p = plurals[i];
                if (left.includes(b) || left.includes(p)) flags.set(names[i], true);
                if (right.includes(b) || right.includes(p)) flags.set(names[i], false);
              }
            }
            const equipRe = /(equipped with|can be equipped with|can be equipped|can be given)[\s\S]*?(?:\.|\n|$)/g;
            while ((m = equipRe.exec(text))){
              const seg = m[0];
              for (let i=0;i<names.length;i++){
                const b = bases[i]; const p = plurals[i];
                if (seg.includes(b) || seg.includes(p)) flags.set(names[i], false);
              }
            }
            return flags;
          };
          const flagsAI = computeDefaultFlagsAI(oppAllWeapons, oppOptions);
          oppAllWeapons.forEach(w => { w.isStandard = !!flagsAI.get(w.name); });
        } catch { /* ignore, falls back below */ }
        const oppRanged = uniqByBase(oppAllWeapons.filter(w=>w.type==='ranged' && w.isStandard));
        const oppMelee  = uniqByBase(oppAllWeapons.filter(w=>w.type==='melee' && w.isStandard));
  let oppWeps = [];
        if (sel.weaponType === 'ranged') {
          // 40K: models can shoot all their ranged weapons; use all default ranged (deduped by base name)
          oppWeps = oppRanged;
        } else {
          if (oppMelee.length) oppWeps = [oppMelee[0]];
        }
  // No fallback: AI must use default wargear only. If none for the chosen type, it will not fire this round.
  // Fight loop until winner (safety cap rounds=20)
    const matchId = `m_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,7)}`;
        // Show and reset text log panel
        showLogRow();
        if (matchIdLabel) matchIdLabel.textContent = matchId;
  clearTextLog();
    let myHP = detail.stats.W;
        let aiHP = oppDetail.stats.W;
        const aggregate = {Attacks:0, Hits:0, Wounds:0, Saved:0, Unsaved:0, DamageTotal:0, Logs:[]};
    let round = 1;
  const titleBase = `Combat (Match ${matchId})`;
    let stopRequested = false;
    document.getElementById('btnStopFight')?.addEventListener('click', ()=>{ stopRequested = true; }, { once: true });
  while (!stopRequested && myHP > 0 && aiHP > 0) {
          aggregate.Logs.push(`— Round ${round} —`);
          setTextLog(aggregate.Logs);
          // Player volley
          try { aggregate.Logs.push(`Player selected: ${weps.map(w=>w.name).join(', ') || '(none)'}`); setTextLog(aggregate.Logs); } catch {}
          for (const wpn of weps) {
            const payload = {
              attacker: { id: sel.unitId, name: sel.user || 'You', T: detail.stats.T, W: myHP, Sv: detail.stats.Sv, InvSv: detail.stats.InvSv, keywords: (detail.keywords||[]), abilities: (detail.abilities||[]) },
              defender: { id: 'AI', name: 'AI', T: oppDetail.stats.T, W: aiHP, Sv: oppDetail.stats.Sv, InvSv: oppDetail.stats.InvSv, keywords: (oppDetail.keywords||[]), abilities: (oppDetail.abilities||[]) },
      weapon: wpn,
      match_id: matchId,
      meta: { actor: sel.user || 'You', round, step: 1 },
            };
            const resp = await fetch('/api/sim/shoot', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const res = await resp.json();
            // update aggregates
            aggregate.Attacks += (res.attacks||res.Attacks||0);
            aggregate.Hits    += (res.hits||res.Hits||0);
            aggregate.Wounds  += (res.wounds||res.Wounds||0);
            aggregate.Saved   += (res.saved||res.Saved||0);
            aggregate.Unsaved += (res.unsaved||res.Unsaved||0);
            aggregate.DamageTotal += (res.damage_total||res.DamageTotal||0);
            // Track best single volley (by wounds, tie-break by damage)
            {
              const wounds = (res.unsaved||res.Unsaved||0);
              const damage = (res.damage_total||res.DamageTotal||0);
              if (wounds > 0) {
                const prev = aggregate.TopAttack || null;
                const better = !prev || (wounds > (prev.wounds||0)) || (wounds === (prev.wounds||0) && damage > (prev.damage||0));
                if (better) {
                  aggregate.TopAttack = { user: (sel.user||'You'), unit: (detail.name||''), weapon: wpn.name, wounds, damage };
                }
              }
            }
            aiHP = Math.max(0, (res.defender_wounds ?? res.DefenderWounds ?? aiHP));
            const pfx = `${sel.user || 'You'} ${detail.name} ${wpn.name}`;
            (res.logs||res.Logs||[]).forEach(l=> aggregate.Logs.push(`${pfx}: ${l}`));
            if (aiHP <= 0) {
              aggregate.Logs.push('== You win ==');
              drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, 'You win');
              setTextLog(aggregate.Logs);
              stopRequested = true;
              break;
            }
            // Redraw after each weapon volley (player)
            drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, null, { attacker: sel.user || 'You', weaponName: wpn.name, defender: oppDetail.name || 'AI', weaponAbilities: wpn.abilities||[], usedLeft: weps, usedRight: oppWeps });
            setTextLog(aggregate.Logs);
            await sleep(120);
            if (stopRequested) break;
          }
          if (stopRequested || aiHP <= 0) break;
          // Player selection debug removed to keep logs concise
          // AI volley: use chosen opponent weapons
          try { aggregate.Logs.push(`AI selected: ${oppWeps.map(w=>w.name).join(', ') || '(none)'}`); setTextLog(aggregate.Logs); } catch {}
          for (const wpn of oppWeps) {
            const payload = {
              attacker: { id: oppUnitId, name: oppDetail.name || 'AI', T: oppDetail.stats.T, W: aiHP, Sv: oppDetail.stats.Sv, InvSv: oppDetail.stats.InvSv, keywords: (oppDetail.keywords||[]), abilities: (oppDetail.abilities||[]) },
              defender: { id: sel.unitId, name: sel.user || 'You', T: detail.stats.T, W: myHP, Sv: detail.stats.Sv, InvSv: detail.stats.InvSv, keywords: (detail.keywords||[]), abilities: (detail.abilities||[]) },
              weapon: wpn,
              match_id: matchId,
              meta: { actor: 'AI', round, step: 2 },
            };
            const resp = await fetch('/api/sim/shoot', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const res = await resp.json();
            myHP = Math.max(0, (res.defender_wounds ?? res.DefenderWounds ?? myHP));
            const pfx = `AI ${oppDetail.name||'Unit'} ${wpn.name}`;
            (res.logs||res.Logs||[]).forEach(l=> aggregate.Logs.push(`${pfx}: ${l}`));
            // Track AI volley as well
            {
              const wounds = (res.unsaved||res.Unsaved||0);
              const damage = (res.damage_total||res.DamageTotal||0);
              if (wounds > 0) {
                const prev = aggregate.TopAttack || null;
                const better = !prev || (wounds > (prev.wounds||0)) || (wounds === (prev.wounds||0) && damage > (prev.damage||0));
                if (better) {
                  aggregate.TopAttack = { user: 'AI', unit: (oppDetail.name||'Unit'), weapon: wpn.name, wounds, damage };
                }
              }
            }
            if (myHP <= 0) {
              aggregate.Logs.push(`== ${oppDetail.name||'AI'} wins ==`);
              drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, `${oppDetail.name||'AI'} wins`);
              setTextLog(aggregate.Logs);
              stopRequested = true;
              break;
            }
            // Redraw after each weapon volley (AI)
            drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, null, { attacker: oppDetail.name || 'AI', weaponName: wpn.name, defender: sel.user || 'You', weaponAbilities: wpn.abilities||[], usedLeft: weps, usedRight: oppWeps });
      setTextLog(aggregate.Logs);
            await sleep(120);
            if (stopRequested) break;
          }
          round++;
        }
  const winner = stopRequested ? 'Stopped' : myHP <= 0 ? `${oppDetail.name||'AI'} wins` : aiHP <= 0 ? 'You win' : 'Ended';
        aggregate.Logs.push(`== ${winner} ==`);
    drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase);
  setTextLog(aggregate.Logs);
  // Update statistics after fight
  updateStatistics(aggregate);
  // Keep the canvas visible after the fight ends, including when stopped.
      } catch (e) {
        console.error(e);
  drawSplash();
  hideFightSurface();
  showPostMatchUI();
        alert('Failed to simulate shooting: ' + (e && e.message || e));
      }
    });

  // Statistics update logic
  function updateStatistics(aggregate) {
  // Always show statistics panel after updating
  let statsBoxUpdate = document.getElementById('statsBox');
  if (statsBoxUpdate) statsBoxUpdate.classList.remove('d-none');
  // Highest Damage Attack
  const statBestSave = document.getElementById('statBestSave');
  const statWorstSave = document.getElementById('statWorstSave');
  let topDamage = '—';
    const bestSave = aggregate.Saved > 0 ? aggregate.Saved : '—';
    const worstSave = aggregate.Unsaved > 0 ? aggregate.Unsaved : '—';
  // Find highest damage attack (unsaved only). Prefer structured TopAttack; else parse log.
  let topAttack = aggregate.TopAttack || null;
    let topAttackVal = topAttack ? (topAttack.damage||0) : 0;
  if (!topAttack && Array.isArray(aggregate.Logs)) {
      for (const l of aggregate.Logs) {
        // Only count attacks that caused wounds (unsaved damage)
        // Example log: "User Unit Weapon: ... 3 damage (2 wounds)"
        const m = l.match(/(\w+) (.+?) (.+?):.*?(\d+) damage \((\d+) wounds\)/);
        if (m) {
          const wounds = parseInt(m[5],10);
          if (wounds > 0) {
            const dmg = parseInt(m[4],10);
            if (dmg > topAttackVal) {
              topAttackVal = dmg;
              topAttack = { user: m[1], unit: m[2], weapon: m[3], damage: dmg, wounds };
            }
          }
        }
      }
    }
    const statTopDamageDetails = document.getElementById('statTopDamageDetails');
    let topDamageDetails = '—';
    if (topAttack) {
      const attacker = topAttack.user || 'Anonymous';
      topDamageDetails = `${attacker}: ${topAttack.unit} - ${topAttack.weapon} ${topAttack.damage} damage (${topAttack.wounds} wounds)`;
    }
  if (statTopDamageDetails) statTopDamageDetails.textContent = topDamageDetails;
  // Set big number to damage from biggest single attack
  topDamage = topAttack ? topAttack.damage : '—';
    // Build a structured maxAttack object for server-side persistence
    let maxAttack = null;
    if (topAttack) {
      const attacker = topAttack.user || 'Anonymous';
      maxAttack = { username: attacker, unit: topAttack.unit, weapon: topAttack.weapon, wounds: topAttack.wounds, damage: topAttack.damage };
    }
    // Persist to server
    try {
      const username = sessionStorage.getItem('username') || 'Anonymous';
      fetch('/api/stats/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, stats: { topDamage, bestSave, worstSave, topDamageDetails, maxAttack } })
      }).catch(()=>{});
      if (maxAttack) {
        fetch('/api/stats/max-attack/today', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ attack: maxAttack })
        }).then(()=>{
          // Refresh from global so we show today's leader (not just this fight's)
          return fetch('/api/stats/max-attack/today');
    }).then(r=> r && r.ok ? r.json() : null).then(g=>{
          if (g && g.username && g.weapon) {
            const statTopDamageDetails = document.getElementById('statTopDamageDetails');
            const dmg = g.damage || 0;
      const wnd = g.wounds || 0;
      if (statTopDamageDetails) statTopDamageDetails.textContent = `${g.username}: ${g.unit} - ${g.weapon} ${dmg} damage (${wnd} wounds)`;
          }
        }).catch(()=>{});
      }
    } catch {}
  if (statBestSave) statBestSave.textContent = bestSave;
  if (statWorstSave) statWorstSave.textContent = worstSave;
  const statsBox = document.getElementById('statsBox');
  if (statsBox) statsBox.classList.remove('d-none');
  }
    document.getElementById('btnMatchmake').addEventListener('click', ()=>{
      const sel = ensureSelection();
      if (!sel) return;
      console.log('Queue for PVP matchmaking with selection:', sel);
  hidePreMatchUI();
      // TODO: call backend to join matchmaking queue
  fetch('/api/lobby/phase', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: sel.user, phase: 'queue'})}).catch(()=>{});
    });
    // Log action buttons
    document.getElementById('btnCopyLog')?.addEventListener('click', copyTextLog);
    document.getElementById('btnDownloadLog')?.addEventListener('click', ()=>{
      const id = (matchIdLabel?.textContent || '').trim() || 'match';
      const txt = textLogEl?.textContent || '';
      download(`${id}.txt`, txt, 'text/plain');
    });
    document.getElementById('btnDownloadJSON')?.addEventListener('click', ()=>{
      const id = (matchIdLabel?.textContent || '').trim();
      if (id && id !== '—') downloadJSONLog(id);
    });
  </script>
</body>
</html>
