<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>W40K Duel ‚Äì Mockup</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Web fonts (display + UI) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Theme stylesheet (Warhammer-inspired) -->
  <link href="/styles.css" rel="stylesheet">
  <style>
    /* Winner overlay */
    .victory-overlay{position:fixed;inset:0;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;z-index:1050}
    .vo-card{background:#0b1016;border:1px solid #c9a753;border-radius:14px;padding:24px 24px 20px;max-width:560px;width:min(92vw,560px);text-align:center;box-shadow:0 0 40px rgba(0,0,0,.6)}
    .vo-title{color:#c9a753;font-family:'Cinzel',serif;font-weight:700;font-size:1.5rem}
    .vo-sub{color:#8aa0b8;font-size:.95rem;margin-top:.25rem}
    .vo-meta{color:#5a6c7d;font-size:.8rem;margin-top:.5rem}
    .vo-actions{margin-top:16px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <!-- Top Banner -->
  <header class="banner py-3 mb-3">
    <div class="container d-flex align-items-center justify-content-between">
      <h1 class="h4 m-0">W40K Duel</h1>
    <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end w-100" style="max-width: 750px;">
  <div class="user-name-BOX_un_ d-none" id="userNameBox">Username: <span id="userName">Anonymous</span></div>
        <div class="username-input-BOX_ui_ input-group input-group-sm" style="max-width: 280px;">
          <input id="usernameInput" type="text" class="form-control bg-dark text-light border-secondary" placeholder="Enter username" aria-label="username">
          <button id="usernameSaveBtn" class="btn btn-warning" type="button">OK</button>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container">
    <!-- Build info footer bar -->
    <div id="buildInfoBar" class="position-fixed bottom-0 start-0 end-0 py-1 px-2" style="background:rgba(0,0,0,0.7); border-top:1px solid rgba(201,167,83,.4); z-index:1030;">
      <div class="container d-flex justify-content-between small" style="color:#8aa0b8;">
        <div>Build: <span id="buildCommit">dev</span></div>
        <div><span id="buildTime"></span></div>
      </div>
    </div>
    <!-- Selection controls -->
    <div class="row mb-3 selection-BOX_sel_">
      <div class="col-12 col-md-4 mb-2 mb-md-0">
        <label for="factionSelect" class="form-label">Faction</label>
        <select id="factionSelect" class="form-select"></select>
      </div>
      <div class="col-12 col-md-4 mb-2 mb-md-0">
        <label for="unitSelect" class="form-label">Unit</label>
        <select id="unitSelect" class="form-select" disabled></select>
      </div>
      <div class="col-12 col-md-4">
        <label class="form-label d-block">Weapon Type</label>
        <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap">
          <div class="weapon-type-BOX_wt_ btn-group" role="group" aria-label="Weapon type">
            <input type="radio" class="btn-check" name="weaponType" id="wtRanged" autocomplete="off" checked>
            <label class="btn btn-outline-warning" for="wtRanged">Ranged</label>
            <input type="radio" class="btn-check" name="weaponType" id="wtMelee" autocomplete="off">
            <label class="btn btn-outline-warning" for="wtMelee">Melee</label>
          </div>
          <div class="action-buttons-BOX_ab_ btn-group" role="group" aria-label="Actions">
            <button id="btnFightAI" class="btn btn-outline-warning">Fight AI</button>
            <button id="btnMatchmake" class="btn btn-outline-warning">Matchmake</button>
            <button id="btnCancelMatchmake" class="btn btn-outline-danger d-none">Cancel Search</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Weapon Selection (appears after unit selection) -->
    <div class="row mb-3 d-none" id="weaponSelectRow">
      <div class="col-12">
        <div class="stats-box p-3">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Weapon Selection</h2>
            <div class="text-secondary small" id="weaponSelectSummary">‚Äî</div>
          </div>
          <!-- Quick Selection Buttons -->
          <div class="d-flex gap-2 mb-3 flex-wrap">
            <button id="btnDefaultLayout" class="btn btn-sm btn-success" title="Select the standard/default wargear for this unit">‚öîÔ∏è Default Layout</button>
            <button id="btnSelectAllRanged" class="btn btn-sm btn-outline-info" title="Select all available ranged weapons (one per weapon type)">Select All Ranged</button>
            <button id="btnSelectAllMelee" class="btn btn-sm btn-outline-info" title="Select the default melee weapon">Select All Melee</button>
            <button id="btnMaxPower" class="btn btn-sm btn-warning" title="Automatically select the highest damage weapons available">‚ö° Max Power!</button>
            <button id="btnClearWeapons" class="btn btn-sm btn-outline-secondary" title="Clear all weapon selections">Clear All</button>
            <button id="btnCalcOdds" class="btn btn-sm btn-outline-warning" title="Estimate win% vs mirror enemy">Calculate Odds</button>
            <span id="calcOddsResult" class="small text-secondary"></span>
          </div>
          <!-- Optional: Opponent selection for odds -->
          <div class="row g-2 mb-2">
            <div class="col-12 col-md-4">
              <label class="form-label small text-secondary" for="oppFactionSelect">Opponent Faction (optional)</label>
              <select id="oppFactionSelect" class="form-select form-select-sm">
                <option value="">(same as yours)</option>
              </select>
            </div>
            <div class="col-12 col-md-4">
              <label class="form-label small text-secondary" for="oppUnitSelect">Opponent Unit (optional)</label>
              <select id="oppUnitSelect" class="form-select form-select-sm" disabled>
                <option value="">(same unit)</option>
              </select>
            </div>
            <div class="col-12 col-md-4 d-flex align-items-end">
              <div class="small text-secondary">Tip: leave blank to mirror your unit.</div>
            </div>
          </div>
          <div id="weaponSelectBox" class="row g-2"></div>
        </div>
      </div>
    </div>

    <div class="row mb-3">
      <div class="col-12">
        <div class="game-window-BOX_gw_ game-surface p-2 d-none" id="gameWindow">
          <canvas id="gameCanvas" class="w-100" style="display:block; width: 100%; height: auto; aspect-ratio: 16/9; background:#0a0c10;"></canvas>
        </div>
      </div>
    </div>

    <!-- Winner Splash Overlay -->
    <div id="victoryOverlay" class="victory-overlay d-none" aria-live="polite" aria-modal="true" role="dialog">
      <div class="vo-card">
        <div class="vo-title" id="voTitle">üèÜ Victory</div>
        <div class="vo-sub" id="voSubtitle">Glory to the winner.</div>
        <div class="vo-meta" id="voMeta">Mode: <span id="voMode">‚Äî</span> ‚Ä¢ Match: <code id="voMatch">‚Äî</code></div>
        <div class="vo-actions">
          <button id="voNewMatch" class="btn btn-warning">New Match</button>
          <button id="voClose" class="btn btn-outline-secondary">Close</button>
        </div>
      </div>
    </div>

    <!-- Copyable Fight Log Panel -->
    <div class="row mb-3" id="logRow" style="display:none;">
      <div class="col-12">
        <div class="stats-box p-3">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Fight Log <small class="text-secondary">(Match <code id="matchIdLabel">‚Äî</code>)</small></h2>
            <div class="btn-group btn-group-sm" role="group" aria-label="log actions">
              <button id="btnCopyLog" class="btn btn-outline-secondary" type="button">Copy</button>
              <button id="btnDownloadLog" class="btn btn-outline-secondary" type="button">Download .txt</button>
              <button id="btnDownloadJSON" class="btn btn-outline-secondary" type="button">Download JSON</button>
              <button id="btnStopFight" class="btn btn-outline-danger" type="button" title="Stop the current fight">Stop</button>
            </div>
          </div>
          <pre id="textLog" class="mt-2 bg-dark text-light p-2 border border-secondary rounded" style="max-height: 240px; overflow-y: auto; white-space: pre-wrap;">(no log yet)</pre>
        </div>
      </div>
    </div>

  <!-- Lobby Panel (moved above Statistics) -->
  <div class="row mt-3 mb-4">
      <div class="col-12">
        <div class="stats-box p-3" id="lobbyBox">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <h2 class="h6 text-warning m-0">Lobby</h2>
            
          </div>
          <div id="lobbyList" class="row g-2"></div>
        </div>
      </div>
    </div>

  <!-- Bottom Stats -->
  <div class="row">
      <div class="col-12">
        <div class="stats-BOX_sb_ stats-box p-3" id="statsBox">
          <h2 class="h6 text-warning mb-3">Statistics</h2>
          <div class="row g-3">
            <div class="col-12 col-md-6">
              <div class="card bg-dark border-secondary high-dmg-BOX_hd_">
                <div class="card-body py-3">
                  <div class="text-secondary small">Highest Damage Attack (single volley)</div>
                  <div id="statTopDamageDetails" class="small text-secondary">‚Äî</div>
                </div>
              </div>
            </div>
            <div class="col-12 col-md-6">
              <div class="card bg-dark border-secondary saves-BOX_sv_">
                <div class="card-body py-3">
                  <div class="text-secondary small">Best & Worst Save</div>
                  <div class="d-flex gap-4">
                    <div>Best: <span id="statBestSave" class="fw-bold">‚Äî</span></div>
                    <div>Worst: <span id="statWorstSave" class="fw-bold">‚Äî</span></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
var stats = {};
  // Restore statistics from server (fallback to localStorage)
  async function restoreStatistics() {
  const statTopDamage = null; // removed big number
    const statBestSave = document.getElementById('statBestSave');
    const statWorstSave = document.getElementById('statWorstSave');
    const statTopDamageDetails = document.getElementById('statTopDamageDetails');
    const username = sessionStorage.getItem('username') || 'Anonymous';
    let usedGlobal = false;
  // Try to load today's global max attack first
    try {
      const g = await fetch('/api/stats/max-attack/today').then(r=> r.ok ? r.json() : null).catch(()=>null);
      if (g && g.username && g.weapon) {
    const dmg = g.damage || 0;
    const wnd = g.wounds || 0;
  // big number removed
    if (statTopDamageDetails) statTopDamageDetails.textContent = `${g.username}: ${g.unit} - ${g.weapon} ${dmg} damage (${wnd} wounds)`;
        usedGlobal = true;
      }
    } catch {}
    try {
      const s = await fetch(`/api/stats/get?username=${encodeURIComponent(username)}`).then(r=>r.json());
      stats = s || {};
    } catch {
      stats = JSON.parse(localStorage.getItem('w40kduel_stats') || '{}');
    }
  // big number removed
    if (statBestSave && stats.bestSave !== undefined) statBestSave.textContent = stats.bestSave;
    if (statWorstSave && stats.worstSave !== undefined) statWorstSave.textContent = stats.worstSave;
  if (!usedGlobal && statTopDamageDetails && stats.topDamageDetails !== undefined) statTopDamageDetails.textContent = stats.topDamageDetails;
  // Also fetch biggest per-user attack from server and display if present
    try {
      if (!usedGlobal) {
        const ma = await fetch(`/api/stats/max-attack?username=${encodeURIComponent(username)}`).then(r=>r.json());
        if (ma && ma.username) {
      const dmg = ma.damage || 0;
      const wnd = ma.wounds || 0;
      const det = `${ma.username}: ${ma.unit} - ${ma.weapon} ${dmg} damage (${wnd} wounds)`;
      if (statTopDamageDetails) statTopDamageDetails.textContent = det;
          // big number removed
        }
      }
    } catch {}
    let statsBoxRestore = document.getElementById('statsBox');
    if (statsBoxRestore) statsBoxRestore.classList.remove('d-none');
  }
  restoreStatistics();
  // Demo: set names via query params ?user=... (player removed)
  const params = new URLSearchParams(location.search);

  // Randomize top-bar app name from provided list (new each refresh)
  (function(){
    const names = [
      'Grimdark Slapfight 9000 ‚Äì because the galaxy needed more petty violence.',
      'Bolter & Banter ‚Äì competitive shooting and trash talking.',
      'Chainswords at Dawn ‚Äì the most civilized way to settle things in the 41st millennium.',
      'The Emperor‚Äôs Smackdown ‚Äì sanctioned by His Holy Fist‚Ñ¢.',
      'Pew Pew Heresy ‚Äì for when you‚Äôre not quite excommunicate traitoris yet.',
      'Spiky Pauldrons of Destiny ‚Äì the real source of power in 40K.',
      'Rogal Dorn‚Äôs Slap Chop ‚Äì build it, fortify it, then chop it.',
      'Lasgun Legends: Missing Every Shot Since M2 ‚Äì accuracy optional.',
      'Heretic Hugfest 3000 ‚Äì love hurts, and so do chainaxes.',
      'Purging for Fun & Profit ‚Äì guaranteed to cleanse and earn.',
      'ORKtagon ‚Äì where only the biggest and greenest survive.',
      'Spiritual Lieutenants of Eternal War ‚Äì more titles than actual victories.',
      'Dakka Diplomacy ‚Äì negotiations conducted exclusively with bullets.',
      'Smite Club ‚Äì first rule: always manifest on an 11+.',
      'Bayonets & Bureaucracy ‚Äì Astra Militarum in a nutshell.',
      'Chainsword Shuffle ‚Äì one step forward, three limbs gone.',
      'Warpstorm Wrestling ‚Äì chaos reigns and suplexes are allowed.',
      'The Guilliman Games ‚Äì sanctioned sporting events of ultramar excellence.',
      'Kroot Cook-Off ‚Äì winner eats the loser, literally.',
      'Ghazghkull‚Äôs Punch-Up Parade ‚Äì loud, messy, and somehow festive.',
      'Servo Skull Smackfest ‚Äì flying drones, flying teeth.',
      'Melta at Midday ‚Äì quick draw, quicker vaporization.',
      'The Lascannon Lottery ‚Äì will it hit? statistically, no.',
      'Daemonhost Dance-Off ‚Äì where the music is screaming souls.',
      'Battle-Barge Ballroom Blitz ‚Äì formal attire: powered armour.',
      'Sanguinius Says ‚Äì follow the primarch‚Äôs commands‚Ä¶ or else.',
      'Astartes Arm Wrestling ‚Äì table reinforced with adamantium.',
      'Catachan Cage Match ‚Äì the cage is made of razorwire and snakes.'
    ];
    // Deduplicate just in case future edits add overlaps
    const unique = Array.from(new Set(names.map(s => s.trim())));
    const chosen = unique[Math.floor(Math.random() * unique.length)];
    const headerEl = document.querySelector('header.banner h1');
    if (headerEl) headerEl.textContent = chosen;
    // Also set the browser tab title
    try { document.title = chosen; } catch {}
  })();

  const usernameDisplay = document.getElementById('userName');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSaveBtn = document.getElementById('usernameSaveBtn');
  const userNameBoxEl = document.getElementById('userNameBox');
  const usernameInputGroup = document.querySelector('.username-input-BOX_ui_');

    async function setUsername(name){
      const clean = (name || '').trim() || 'Anonymous';
      sessionStorage.setItem('username', clean);
      usernameDisplay.textContent = clean;
      usernameInput.value = clean;
      userNameBoxEl.classList.remove('d-none');
  // Hide the input group once chosen
  if (usernameInputGroup) usernameInputGroup.classList.add('d-none');
      // Join lobby
      try {
        await fetch('/api/lobby/join', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: clean})});
      } catch {}
    }

    // Initialize username: show only if previously chosen in this session
    const stored = sessionStorage.getItem('username');
    if (stored && stored.trim()) {
      setUsername(stored.trim());
    } else {
      const qpUser = params.get('user');
      if (qpUser && qpUser.trim()) {
        // Pre-fill input only; do not consider as chosen until saved
        usernameInput.value = qpUser.trim();
      }
    }

    // Save on click or Enter
    usernameSaveBtn.addEventListener('click', ()=> setUsername(usernameInput.value));
    usernameInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') setUsername(usernameInput.value);
    });

    // Populate factions and units from API
    const factionSelect = document.getElementById('factionSelect');
    const unitSelect = document.getElementById('unitSelect');
    let factions = [];

    async function loadFactions(){
      try {
        const resp = await fetch('/api/factions');
        factions = await resp.json();
        factionSelect.innerHTML = '<option value="">Select Faction</option>' +
          factions.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
        // Auto-select first faction to make units appear immediately
        if (Array.isArray(factions) && factions.length > 0) {
          const first = factions[0];
          if (first && first.id) {
            factionSelect.value = first.id;
            loadUnitsForFaction(first.id);
          }
        }
      } catch(e){
        factionSelect.innerHTML = '<option value="">(failed to load factions)</option>';
      }
    }

    async function loadUnitsForFaction(fid){
      unitSelect.disabled = true;
      unitSelect.innerHTML = '<option value="">Loading units‚Ä¶</option>';
      if(!fid){ unitSelect.innerHTML = '<option value="">Select unit</option>'; return; }
      try {
    const resp = await fetch(`/api/${encodeURIComponent(fid)}/units`);
        const units = await resp.json();
        unitSelect.innerHTML = '<option value="">Select Unit</option>' +
          units.map(u => {
            const id = u.ID || u.id || u.Name || u.name;
            const name = u.Name || u.name || 'Unit';
            const t = (u.T ?? u.t ?? '‚Äì');
            const w = (u.W ?? u.w ?? '‚Äì');
      const pts = (u.points || u.Points || '').toString();
      const ptsTxt = pts ? ` ‚Äî ${pts}pts` : '';
      return `<option value="${id}" data-points="${pts}">${name} (T ${t} / W ${w})${ptsTxt}</option>`;
          }).join('');
        unitSelect.disabled = false;
      } catch(e){
        unitSelect.innerHTML = '<option value="">(failed to load units)</option>';
      }
    }

    factionSelect.addEventListener('change', (e)=>{
      const fid = e.target.value;
      loadUnitsForFaction(fid);
    });

    // Show/update weapon selection when a unit is chosen
    const weaponSelectRow = document.getElementById('weaponSelectRow');
    const weaponSelectBox = document.getElementById('weaponSelectBox');
    const weaponSelectSummary = document.getElementById('weaponSelectSummary');
  const weaponCatalog = { ranged: [], melee: [] };
  const weaponSelection = { ranged: new Set(), melee: null };
  // Controls whether the weapon selection panel may be shown
  let allowSelectionUI = true;

    function renderWeaponSelection(){
      if (!weaponSelectBox) return;
      const type = getWeaponType();
      const items = type === 'melee' ? weaponCatalog.melee : weaponCatalog.ranged;
      const isMelee = type === 'melee';
      const selCount = isMelee ? (weaponSelection.melee ? 1 : 0) : weaponSelection.ranged.size;
  const capTxt = isMelee ? 'select 1' : 'select any';
      if (weaponSelectSummary) weaponSelectSummary.textContent = `${type.toUpperCase()} ‚Äî ${selCount} selected (${capTxt})`;

      // Group weapons by base name (e.g., Plasma Gun) and show modes as radio buttons
      const groupByBase = {};
      items.forEach((w,i)=>{
        // Extract base name and mode
        const m = w.name.match(/^(.*?)(?: \((.*?)\))?$/);
        const base = m ? m[1].trim() : w.name;
        const mode = m && m[2] ? m[2].trim() : 'Standard';
        if (!groupByBase[base]) groupByBase[base] = [];
        groupByBase[base].push({...w, mode, idx: i});
      });
      const controls = Object.entries(groupByBase).map(([base, arr])=>{
        // If only one mode, render as before
        if (arr.length === 1) {
          const w = arr[0];
          const id = `wp_${type}_${w.idx}`;
          const ab = (Array.isArray(w.abilities) && w.abilities.length) ? `[${w.abilities.join(', ')}]` : '';
          const rangeTxt = (w.range && w.range.toLowerCase()!=='melee') ? ` | ${w.range}` : '';
          const descRaw = (w.desc||'').trim().replace(/\s+/g,' ');
          const descTxt = cleanDescriptionAgainstAbilities(descRaw, w.abilities||[]);
          const defaultLabel = w.isStandard ? '<span class="wo-default text-primary ms-2" style="font-weight:600;">(default)</span>' : '';
          const body = `
            <div class="weapon-option">
              <div class="d-flex gap-2 align-items-start">
                <input class="form-check-input mt-1" type="${isMelee?'radio':'checkbox'}" ${isMelee? 'name="meleeWpn"':''} id="${id}" data-name="${encodeURIComponent(w.name)}" ${isMelee ? (weaponSelection.melee===w.name?'checked':'') : (weaponSelection.ranged.has(w.name)?'checked':'')}>
                <label class="form-check-label w-100" for="${id}">
                  <div class="wo-name">${w.name} ${ab? `<span class="wo-abilities">${ab}</span>`:''} ${defaultLabel}</div>
                  <div class="wo-stats">A ${w.attacks} | Skill ${w.skill}+ | S ${w.strength} | AP ${w.ap} | D ${w.damage}${rangeTxt}</div>
                  ${descTxt ? `<div class="wo-desc">${descTxt}</div>`:''}
                </label>
              </div>
            </div>`;
          return `<div class="col-12 col-md-6">${body}</div>`;
        }
        // Multiple modes: render radio group
        const radioName = `wpgrp_${type}_${base.replace(/\W/g,'_')}`;
        const radios = arr.map(w=>{
          const id = `wp_${type}_${w.idx}`;
          const ab = (Array.isArray(w.abilities) && w.abilities.length) ? `[${w.abilities.join(', ')}]` : '';
          const rangeTxt = (w.range && w.range.toLowerCase()!=='melee') ? ` | ${w.range}` : '';
          const descRaw = (w.desc||'').trim().replace(/\s+/g,' ');
          const descTxt = cleanDescriptionAgainstAbilities(descRaw, w.abilities||[]);
          const defaultLabel = w.isStandard && w.mode==='Standard' ? '<span class="wo-default text-primary ms-2" style="font-weight:600;">(default)</span>' : '';
          const checked = isMelee ? (weaponSelection.melee===w.name?'checked':'') : (weaponSelection.ranged.has(w.name)?'checked':'');
          return `<div class="weapon-option">
            <div class="d-flex gap-2 align-items-start">
              <input class="form-check-input mt-1" type="radio" name="${radioName}" id="${id}" data-name="${encodeURIComponent(w.name)}" ${checked}>
              <label class="form-check-label w-100" for="${id}">
                <div class="wo-name">${base} <span class="wo-mode text-info ms-1">(${w.mode})</span> ${ab? `<span class="wo-abilities">${ab}</span>`:''} ${defaultLabel}</div>
                <div class="wo-stats">A ${w.attacks} | Skill ${w.skill}+ | S ${w.strength} | AP ${w.ap} | D ${w.damage}${rangeTxt}</div>
                ${descTxt ? `<div class="wo-desc">${descTxt}</div>`:''}
              </label>
            </div>
          </div>`;
        }).join('');
        return `<div class="col-12 col-md-6"><div class="wo-group">${radios}</div></div>`;
      }).join('');
      weaponSelectBox.innerHTML = controls || '<div class="col-12 text-secondary">No weapons found for this type.</div>';

      // Bind change handlers
      const inputs = weaponSelectBox.querySelectorAll('input.form-check-input');
      inputs.forEach(inp => {
        inp.addEventListener('change', (ev)=>{
          const nm = decodeURIComponent(ev.target.getAttribute('data-name')||'');
          if (!nm) return;
          // Find base name for grouping
          const label = inp.closest('.wo-group')?.querySelector('.wo-name')?.textContent || inp.closest('.weapon-option')?.querySelector('.wo-name')?.textContent || '';
          const baseMatch = label.match(/^(.*?)(?:\s*\(|$)/);
          const base = baseMatch ? baseMatch[1].trim() : nm;
          if (isMelee) {
            weaponSelection.melee = nm;
          } else {
            // Remove all modes of this base from selection
            Object.keys(groupByBase).forEach(b=>{
              if (b===base) {
                groupByBase[b].forEach(w=> weaponSelection.ranged.delete(w.name));
              }
            });
            weaponSelection.ranged.add(nm);
          }
          renderWeaponSelection();
        });
      });

      // Update button states
      updateQuickSelectButtons();
    }

    async function populateWeaponSelection(fid, uid){
      if (!fid || !uid) { if (weaponSelectRow) weaponSelectRow.classList.add('d-none'); return; }
      try {
        const [all, options] = await Promise.all([
          pickAnyWeapons(fid, uid),
          fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/options`).then(r=>r.json()).catch(()=>[])
        ]);
        // Compute default flags from options: keep bases default, mark replacements/add-ons non-default
        const computeDefaultFlags = (weps, opts)=>{
          const norm = (s)=> String(s||'').toLowerCase().replace(/[‚Äì‚Äî]/g,'-').replace(/\s+/g,' ').trim();
          const baseNameOf = (n)=> norm(String(n||'').split(/\s[‚Äì‚Äî-]\s/)[0]);
          const pluralize = (b)=> b.endsWith('s') ? b : `${b}s`;
          const text = norm((Array.isArray(opts)? opts:[]).map(o=> (o.description||o.Description||'')).join(' \n '));
          const names = weps.map(w=> w.name);
          const bases = names.map(n=> baseNameOf(n));
          const plurals = bases.map(b=> pluralize(b));
          const flags = new Map(names.map(n=> [n, true]));
          // Replacement phrases: "replace(d) ... with ..." ‚Äî bases stay default, replacements become non-default
          const replRe = /(replace(?:d)?)[\s\S]*? with [\s\S]*?(?:\.|\n|$)/g;
          let m;
          while ((m = replRe.exec(text))){
            const seg = m[0];
            const wi = seg.indexOf(' with ');
            if (wi < 0) continue;
            const left = seg.slice(0, wi);
            const right = seg.slice(wi + 6);
            for (let i=0;i<names.length;i++){
              const b = bases[i]; const p = plurals[i];
              if (left.includes(b) || left.includes(p)) flags.set(names[i], true);
              if (right.includes(b) || right.includes(p)) flags.set(names[i], false);
            }
          }
          // Equipment additions: mark those as non-default
          const equipRe = /(equipped with|can be equipped with|can be equipped|can be given)[\s\S]*?(?:\.|\n|$)/g;
          while ((m = equipRe.exec(text))){
            const seg = m[0];
            for (let i=0;i<names.length;i++){
              const b = bases[i]; const p = plurals[i];
              if (seg.includes(b) || seg.includes(p)) flags.set(names[i], false);
            }
          }
          return flags;
        };
        const flags = computeDefaultFlags(all, options);
        all.forEach(w => { w.isStandard = !!flags.get(w.name); });
        weaponCatalog.ranged = all.filter(w=> w.type==='ranged');
        weaponCatalog.melee = all.filter(w=> w.type==='melee');
        // Pre-check standard weapons
        weaponSelection.ranged = new Set(weaponCatalog.ranged.filter(w=>w.isStandard).map(w=>w.name));
        weaponSelection.melee = weaponCatalog.melee.find(w=>w.isStandard)?.name || null;
        if (weaponSelectRow) {
          if (allowSelectionUI) weaponSelectRow.classList.remove('d-none');
          else weaponSelectRow.classList.add('d-none');
        }
        
        // Update lobby status to "choosing-weapons"
        const sel = window.currentSelection && window.currentSelection();
        if (sel && sel.user) {
          fetch('/api/lobby/phase', {
            method: 'POST', 
            headers: {'Content-Type': 'application/json'}, 
            body: JSON.stringify({name: sel.user, phase: 'choosing-weapons'})
          }).catch(()=>{});
        }
        
        renderWeaponSelection();
      } catch {
        if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
      }
    }

    unitSelect.addEventListener('change', (e)=>{
      const fid = factionSelect.value;
      const uid = e.target.value;
      populateWeaponSelection(fid, uid);
    });

    document.getElementById('wtRanged').addEventListener('change', ()=> { renderWeaponSelection(); updateQuickSelectButtons(); });
    document.getElementById('wtMelee').addEventListener('change', ()=> { renderWeaponSelection(); updateQuickSelectButtons(); });

    // Quick weapon selection functions
    function updateQuickSelectButtons() {
      const currentType = getWeaponType();
      const rangedBtn = document.getElementById('btnSelectAllRanged');
      const meleeBtn = document.getElementById('btnSelectAllMelee');
      const maxPowerBtn = document.getElementById('btnMaxPower');
      const defaultBtn = document.getElementById('btnDefaultLayout');
      
      if (rangedBtn && meleeBtn && maxPowerBtn) {
        // Enable/disable buttons based on available weapons and current type
        rangedBtn.disabled = weaponCatalog.ranged.length === 0;
        meleeBtn.disabled = weaponCatalog.melee.length === 0;
        
        // Default button is available if any weapons exist
        if (defaultBtn) {
          defaultBtn.disabled = weaponCatalog.ranged.length === 0 && weaponCatalog.melee.length === 0;
        }
        
        // Highlight the button that matches current weapon type
        rangedBtn.classList.toggle('btn-info', currentType === 'ranged' && weaponCatalog.ranged.length > 0);
        rangedBtn.classList.toggle('btn-outline-info', currentType !== 'ranged' || weaponCatalog.ranged.length === 0);
        
        meleeBtn.classList.toggle('btn-info', currentType === 'melee' && weaponCatalog.melee.length > 0);
        meleeBtn.classList.toggle('btn-outline-info', currentType !== 'melee' || weaponCatalog.melee.length === 0);
      }
    }

    function selectDefaultLayout() {
      // Select only the standard/default wargear as it appears in the codex
      weaponSelection.ranged.clear();
      weaponSelection.melee = null;

      // Select default ranged weapons (marked as isStandard)
      const defaultRanged = weaponCatalog.ranged.filter(w => w.isStandard);
      defaultRanged.forEach(w => weaponSelection.ranged.add(w.name));

      // Select default melee weapon (marked as isStandard)
      const defaultMelee = weaponCatalog.melee.find(w => w.isStandard);
      if (defaultMelee) {
        weaponSelection.melee = defaultMelee.name;
      }

      // Switch to the type with selections, preferring ranged
      if (weaponSelection.ranged.size > 0) {
        document.getElementById('wtRanged').checked = true;
      } else if (weaponSelection.melee) {
        document.getElementById('wtMelee').checked = true;
      }

      renderWeaponSelection();
    }

    function selectAllRanged() {
      if (weaponCatalog.ranged.length === 0) return;
      weaponSelection.ranged.clear();
      // Group by base name and select one weapon per group (preferring default)
      const baseNames = new Set();
      weaponCatalog.ranged.forEach(w => {
        const baseName = w.name.split(/\s[‚Äì‚Äî-]\s/)[0].trim();
        if (!baseNames.has(baseName)) {
          baseNames.add(baseName);
          // Prefer default/standard weapons when available
          const group = weaponCatalog.ranged.filter(wp => wp.name.split(/\s[‚Äì‚Äî-]\s/)[0].trim() === baseName);
          const preferred = group.find(wp => wp.isStandard) || group[0];
          weaponSelection.ranged.add(preferred.name);
        }
      });
      // Switch to ranged view to show selection
      document.getElementById('wtRanged').checked = true;
      renderWeaponSelection();
    }

    function selectAllMelee() {
      if (weaponCatalog.melee.length === 0) return;
      // For melee, select the first/default weapon
      const defaultWeapon = weaponCatalog.melee.find(w => w.isStandard) || weaponCatalog.melee[0];
      weaponSelection.melee = defaultWeapon?.name || null;
      // Switch to melee view to show selection
      document.getElementById('wtMelee').checked = true;
      renderWeaponSelection();
    }

    function selectMaxPower() {
      // Visual feedback for the Max Power button
      const maxPowerBtn = document.getElementById('btnMaxPower');
      const originalText = maxPowerBtn?.textContent;
      if (maxPowerBtn) {
        maxPowerBtn.textContent = '‚ö° SELECTING...';
        maxPowerBtn.disabled = true;
      }

      // Calculate damage potential for each weapon and select highest damage weapons
      const calculateDamagePotential = (weapon) => {
        const attacks = parseFloat(weapon.attacks) || 1;
        const damage = parseFloat(weapon.damage) || 1;
        const strength = weapon.strength || 4;
        const ap = Math.abs(weapon.ap || 0);
        
        // Simple scoring: attacks * damage * strength modifier * AP modifier
        const strengthMod = strength >= 8 ? 1.5 : strength >= 6 ? 1.2 : 1.0;
        const apMod = ap >= 3 ? 1.3 : ap >= 2 ? 1.15 : ap >= 1 ? 1.1 : 1.0;
        
        return attacks * damage * strengthMod * apMod;
      };

      // Clear current selection
      weaponSelection.ranged.clear();
      weaponSelection.melee = null;

      // Select best ranged weapons (group by base name, pick highest damage in each group)
      const rangedGroups = {};
      weaponCatalog.ranged.forEach(w => {
        const baseName = w.name.split(/\s[‚Äì‚Äî-]\s/)[0].trim();
        if (!rangedGroups[baseName] || calculateDamagePotential(w) > calculateDamagePotential(rangedGroups[baseName])) {
          rangedGroups[baseName] = w;
        }
      });
      Object.values(rangedGroups).forEach(w => weaponSelection.ranged.add(w.name));

      // Select best melee weapon
      let bestMelee = null;
      let bestMeleeDamage = 0;
      weaponCatalog.melee.forEach(w => {
        const damage = calculateDamagePotential(w);
        if (damage > bestMeleeDamage) {
          bestMeleeDamage = damage;
          bestMelee = w;
        }
      });
      weaponSelection.melee = bestMelee?.name || null;

      // Switch to the type with more selections, or ranged if tied
      const rangedCount = weaponSelection.ranged.size;
      const meleeCount = weaponSelection.melee ? 1 : 0;
      if (rangedCount >= meleeCount && rangedCount > 0) {
        document.getElementById('wtRanged').checked = true;
      } else if (meleeCount > 0) {
        document.getElementById('wtMelee').checked = true;
      }

      renderWeaponSelection();

      // Restore button after a short delay
      setTimeout(() => {
        if (maxPowerBtn) {
          maxPowerBtn.textContent = originalText;
          maxPowerBtn.disabled = false;
        }
      }, 500);
    }

    function clearAllWeapons() {
      weaponSelection.ranged.clear();
      weaponSelection.melee = null;
      renderWeaponSelection();
    }

    // Add event listeners for quick selection buttons
    document.getElementById('btnDefaultLayout')?.addEventListener('click', selectDefaultLayout);
    document.getElementById('btnSelectAllRanged')?.addEventListener('click', selectAllRanged);
    document.getElementById('btnSelectAllMelee')?.addEventListener('click', selectAllMelee);
    document.getElementById('btnMaxPower')?.addEventListener('click', selectMaxPower);
    document.getElementById('btnClearWeapons')?.addEventListener('click', clearAllWeapons);
  document.getElementById('btnCalcOdds')?.addEventListener('click', calculateOdds);

    // Read selected weapon type
    function getWeaponType(){
      return document.getElementById('wtMelee').checked ? 'melee' : 'ranged';
    }

    // Expose current selection (for future game integration)
  window.currentSelection = () => ({
      user: sessionStorage.getItem('username') || 'Anonymous',
      factionId: factionSelect.value,
      unitId: unitSelect.value,
      weaponType: getWeaponType()
    });

  function getSelectedWeaponsPayload(type){
      const items = type === 'melee' ? weaponCatalog.melee : weaponCatalog.ranged;
      const selected = [];
      if (type === 'melee') {
        const nm = weaponSelection.melee;
        if (nm) {
          const w = items.find(x=> x.name === nm);
          if (w) selected.push({name: w.name, type: type, attacks: String(w.attacks), skill: Number(w.skill||4), strength: Number(w.strength||4), ap: Number(w.ap||0), damage: String(w.damage), abilities: w.abilities||[]});
        }
      } else {
        const set = weaponSelection.ranged;
        items.forEach(w=> { if (set.has(w.name)) selected.push({name: w.name, type: type, attacks: String(w.attacks), skill: Number(w.skill||4), strength: Number(w.strength||4), ap: Number(w.ap||0), damage: String(w.damage), abilities: w.abilities||[]}); });
      }
      return selected;
    }

    // Opponent controls
    const oppFactionSelect = document.getElementById('oppFactionSelect');
    const oppUnitSelect = document.getElementById('oppUnitSelect');
    function syncOppFactionOptions(){
      if (!oppFactionSelect) return;
      // Copy options from main factionSelect
      const opts = Array.from(factionSelect.options).map(o=>({v:o.value, t:o.textContent}));
      oppFactionSelect.innerHTML = '<option value="">(same as yours)</option>' + opts.filter(o=>o.v).map(o=>`<option value="${o.v}">${o.t}</option>`).join('');
    }
    function clearOppUnits(){ if(oppUnitSelect){ oppUnitSelect.innerHTML = '<option value="">(same unit)</option>'; oppUnitSelect.disabled = true; } }
    oppFactionSelect?.addEventListener('change', async (e)=>{
      const fid = e.target.value;
      clearOppUnits();
      if (!fid) return;
      try{
        oppUnitSelect.disabled = true;
        oppUnitSelect.innerHTML = '<option value="">Loading‚Ä¶</option>';
        const units = await fetch(`/api/${encodeURIComponent(fid)}/units`).then(r=>r.json());
        oppUnitSelect.innerHTML = '<option value="">(choose opponent unit)</option>' + units.map(u=> `<option value="${u.id||u.ID}">${u.name||u.Name}</option>`).join('');
        oppUnitSelect.disabled = false;
      }catch{ clearOppUnits(); }
    });

    async function calculateOdds(){
      const out = document.getElementById('calcOddsResult');
      const btn = document.getElementById('btnCalcOdds');
      if (out) out.textContent = '';
      if (btn) { btn.disabled = true; btn.textContent = 'Calculating...'; }
      const fid = factionSelect.value; const uid = unitSelect.value; if (!fid || !uid) { if (out) out.textContent = 'Select a unit first.'; return; }
      const type = getWeaponType();
      const weapons = getSelectedWeaponsPayload(type);
      if (weapons.length === 0) { if (out) out.textContent = 'Select at least one weapon.'; if (btn){ btn.disabled=false; btn.textContent='Calculate Odds'; } return; }
      const username = (sessionStorage.getItem('username')||'Anonymous');
      const oppF = oppFactionSelect?.value || fid;
      const oppU = oppUnitSelect?.value || uid;
      const body = {
        a: { name: username, faction_id: fid, unit_id: uid, weapons },
        b: { name: 'Opponent', faction_id: oppF, unit_id: oppU, weapons },
        trials: 400,
        rotate: true
      };
      try {
        const resp = await fetch('/api/sim/odds', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        if (!resp.ok) {
          const err = await resp.json().catch(()=>({message:'server error'}));
          throw new Error(err.message || 'server error');
        }
        const data = await resp.json();
        const a = Math.round((data.a_win_rate||0)*100);
        const b = Math.round((data.b_win_rate||0)*100);
        if (out) out.textContent = `Win chance: You ${a}% ¬∑ Opponent ${b}% (n=${data.trials})`;
      } catch (e) {
        if (out) out.textContent = 'Calculation failed';
      }
      finally { if (btn){ btn.disabled=false; btn.textContent='Calculate Odds'; } }
    }

  // Init
  loadFactions();
  syncOppFactionOptions();
    // Fetch build info
    (async ()=>{
      try{
        const r = await fetch('/api/version');
        if(!r.ok) return;
        const v = await r.json();
        const c = String(v.commit||'dev');
        const short = c.length>8 ? c.substring(0,8) : c;
        document.getElementById('buildCommit')?.textContent = short;
        const bt = v.build_time ? String(v.build_time) : '';
        document.getElementById('buildTime')?.textContent = bt;
      }catch{}
    })();
    // Canvas helpers
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));
    const gameWindowEl = document.getElementById('gameWindow');
    let hasFightStarted = false;
    function showFightSurface(){ gameWindowEl?.classList.remove('d-none'); }
    function hideFightSurface(){ if (!hasFightStarted) gameWindowEl?.classList.add('d-none'); }
    // Text log helpers
    const logRow = document.getElementById('logRow');
    const textLogEl = document.getElementById('textLog');
    const matchIdLabel = document.getElementById('matchIdLabel');
    function showLogRow(){ if (logRow) logRow.style.display = ''; }
    const TEXT_LOG_LIMIT = 600; // keep last N lines for responsiveness
    function setTextLog(lines){
      if (!textLogEl) return;
      let arr = Array.isArray(lines) ? lines.slice(-TEXT_LOG_LIMIT) : String(lines||'').split('\n');
      const txt = arr.join('\n');
      textLogEl.textContent = txt;
      // autoscroll to bottom
      textLogEl.scrollTop = textLogEl.scrollHeight;
    }
    function clearTextLog(){ setTextLog(''); }
    async function copyTextLog(){
      try { await navigator.clipboard.writeText(textLogEl?.textContent || ''); } catch {}
    }
    function download(filename, content, mime='text/plain'){
      const blob = new Blob([content], {type: mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 500);
    }
    async function downloadJSONLog(matchId){
      if (!matchId) return;
      try {
        const resp = await fetch(`/api/match/${encodeURIComponent(matchId)}`);
        if (!resp.ok) throw new Error('not found');
        const data = await resp.json();
        download(`match_${matchId}.json`, JSON.stringify(data, null, 2), 'application/json');
      } catch {}
    }
    function resizeCanvas(){
      // match displayed size
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.max(320, Math.floor(rect.width));
      const height = Math.max(180, Math.floor(rect.width * 9/16));
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawSplash();
    }
    function drawSplash(){
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      ctx.fillStyle = '#0b1016';
      ctx.fillRect(0,0,w,h);
      
      // Main title
      ctx.fillStyle = '#c9a753';
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.fillText('‚öîÔ∏è W40K Combat Simulator', 12, 24);
      
      // Status
      ctx.fillStyle = '#2ecc71';
      ctx.font = '14px system-ui, sans-serif';
      ctx.fillText('‚óè Ready for Battle', 12, 48);
      
      // Instructions
      ctx.fillStyle = '#8aa0b8';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText('Select your faction, unit & weapons', 12, 72);
      ctx.fillText('Then choose: Fight AI or Matchmake', 12, 88);
      
      // Footer
      ctx.fillStyle = '#5a6c7d';
      ctx.font = '10px system-ui, sans-serif';
      ctx.fillText('In the grim darkness of the far future, there is only war...', 12, h - 12);
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 0);
  // Hide canvas by default until a fight starts
  hideFightSurface();

    // Winner overlay helpers
    function showWinnerOverlay(opts){
      const o = opts||{};
      const overlay = document.getElementById('victoryOverlay');
      const title = document.getElementById('voTitle');
      const sub = document.getElementById('voSubtitle');
      const mode = document.getElementById('voMode');
      const mid = document.getElementById('voMatch');
      title.textContent = `üèÜ ${o.winner ? o.winner + ' wins' : 'Victory'}`;
      sub.textContent = o.subtitle || (o.loser ? `Defeated ${o.loser}` : 'Glory to the victor.');
      mode.textContent = o.mode || 'Match';
      mid.textContent = o.matchId || '‚Äî';
      overlay.classList.remove('d-none');
    }
    function hideWinnerOverlay(){
      document.getElementById('victoryOverlay')?.classList.add('d-none');
    }
    document.getElementById('voClose')?.addEventListener('click', ()=>{ hideWinnerOverlay(); });
    document.getElementById('voNewMatch')?.addEventListener('click', async ()=>{
      hideWinnerOverlay();
      // Set lobby phase back to idle if we know username
      try { const u = sessionStorage.getItem('username') || 'Anonymous'; await fetch('/api/lobby/phase',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name:u,phase:'idle'})}); } catch {}
      showPostMatchUI();
      drawSplash();
    });

    // Data helpers
    const numFrom = (s)=>{
      if (!s) return 0; const m = String(s).match(/\d+/); return m? parseInt(m[0],10):0;
    };
    async function getUnitStats(fid, uid){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/models`);
      const models = await resp.json();
      const m = models && models[0] ? models[0] : {};
      const T = numFrom(m.T) || 4;
      const W = numFrom(m.W) || 5;
      const Sv = numFrom(m.Sv) || 7;
      const InvSv = numFrom(m.inv_sv) || numFrom(m.InvSv) || 0;
      return { T, W, Sv, InvSv };
    }

    async function getUnitDetail(fid, uid){
      // unit basic
      let name = 'Unit';
      let points = null;
      try {
        const u = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}`).then(r=>r.json());
        name = u.name || u.Name || name;
        const p = (u.points ?? u.Points);
        if (p !== undefined && p !== null && String(p).trim() !== '') {
          const n = parseInt(String(p), 10);
          if (!isNaN(n)) points = n;
        }
      } catch {}
      if (name === 'Unit') {
        const opt = Array.from(unitSelect.options).find(o=> o.value==uid);
        if (opt) name = opt.textContent.replace(/\s*\(T .*?\)\s*$/, '').trim() || name;
      }
      // points fallback from the selected option (works for the player's unit)
      if (points === null) {
        const opt = Array.from(unitSelect.options).find(o=> o.value==uid);
        if (opt) {
          const pv = opt.getAttribute('data-points') || '';
          const n = parseInt(pv, 10);
          if (!isNaN(n)) points = n;
        }
      }
      // stats
      const stats = await getUnitStats(fid, uid);
      // abilities
      let abilities = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/abilities`).then(r=>r.json());
        abilities = Array.isArray(list) ? list.map(a=> a.name || a.Name).filter(Boolean) : [];
      } catch {}
      // keywords
      let keywords = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/keywords`).then(r=>r.json());
        keywords = Array.isArray(list) ? list.map(k=> k.keyword || k.Keyword).filter(Boolean) : [];
      } catch {}
      // weapons: include stats for display as text
      let melee = [], ranged = [];
      try {
        const list = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`).then(r=>r.json());
        (Array.isArray(list) ? list : []).forEach(w=>{
          const item = {
            name: w.name || w.Name,
            desc: (w.description || w.Description || '').toString(),
            attacks: (w.attacks || w.Attacks || '').toString(),
            skill: (w.bs_ws || w.BSOrWS || '').toString(),
            strength: (w.strength || w.Strength || '').toString(),
            ap: (w.ap || w.AP || '').toString(),
            damage: (w.damage || w.Damage || '').toString(),
          };
          if (String(w.range).toLowerCase()==='melee') melee.push(item); else ranged.push(item);
        });
      } catch {}
  return { name, points, stats, abilities, keywords, weapons: { melee, ranged } };
    }
    // Extract common weapon abilities from description
    function parseWeaponAbilities(desc){
      const d = String(desc||'').toLowerCase();
      const out = [];
      if (/torrent/.test(d)) out.push('Torrent');
      // Sustained Hits N (any number)
      const sh = d.match(/sustained\s*hits\s*(\d+)/);
      if (sh) out.push(`Sustained Hits ${sh[1]}`);
      if (/lethal\s*hits/.test(d)) out.push('Lethal Hits');
      if (/twin[-\s]?linked/.test(d)) out.push('Twin-linked');
      if (/devastating\s*wounds/.test(d)) out.push('Devastating Wounds');
      if (/heavy/.test(d)) out.push('Heavy');
      if (/blast/.test(d)) out.push('Blast');
      if (/indirect\s*fire/.test(d)) out.push('Indirect Fire');
      if (/ignores\s*cover/.test(d)) out.push('Ignores Cover');
      if (/assault/.test(d)) out.push('Assault');
      if (/pistol/.test(d)) out.push('Pistol');
      const rf = d.match(/rapid\s*fire\s*(\d+)/);
      if (rf) out.push(`Rapid Fire ${rf[1]}`); else if (/rapid\s*fire/.test(d)) out.push('Rapid Fire');
      const mel = d.match(/melta\s*(\d+)/);
      if (mel) out.push(`Melta ${mel[1]}`); else if (/melta/.test(d)) out.push('Melta');
      if (/grenade/.test(d)) out.push('Grenade');
      if (/hazardous/.test(d)) out.push('Hazardous');
      // Anti-<Type> X+
      const antiRe = /anti-([a-z \-]+)\s*(\d)\+/g;
      let m;
      while ((m = antiRe.exec(d)) !== null) {
        const kw = (m[1]||'').trim().replace(/\s+/g,' ');
        const tn = m[2];
        if (kw && tn) out.push(`Anti-${kw} ${tn}+`);
      }
      return out;
    }
    // Remove description tokens that duplicate abilities already shown in brackets
    function cleanDescriptionAgainstAbilities(desc, abilities){
      const raw = String(desc||'');
      if (!raw.trim()) return '';
      const normalize = (s)=> s.toLowerCase()
        .replace(/[+]/g,'')
        .replace(/[^a-z0-9 \-]/g,'')
        .replace(/\s+/g,' ')
        .trim();
      const abilSet = new Set((abilities||[]).map(a=>{
        const n = normalize(a);
        if (n.startsWith('sustained hits')) return 'sustained hits';
        if (n.startsWith('rapid fire')) return 'rapid fire';
        if (n.startsWith('melta')) return 'melta';
        if (n.startsWith('anti-') || n.startsWith('anti ')) return 'anti';
        if (n === 'twin-linked') return 'twin linked';
        return n;
      }));
      const parts = raw.split(/[;,]/).map(t=> t.trim()).filter(Boolean);
      const kept = parts.filter(t=>{
        const n = normalize(t);
        if (!n) return false;
        if (abilSet.has(n)) return false;
        if (n.startsWith('anti') && abilSet.has('anti')) return false;
        if ((n === 'twin linked' || n === 'twin-linked') && (abilSet.has('twin linked'))) return false;
        if (n.startsWith('sustained hits') && abilSet.has('sustained hits')) return false;
        if (n.startsWith('rapid fire') && abilSet.has('rapid fire')) return false;
        if (n.startsWith('melta') && abilSet.has('melta')) return false;
        return true;
      });
      return kept.join(', ');
    }
  // (no-op placeholder removed)
    async function pickWeapons(fid, uid, type){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`);
  const weapons = await resp.json();
  const arr = Array.isArray(weapons) ? weapons : [];
  const isMelee = type === 'melee';
  // Range=='Melee' denotes melee; others are ranged
  const filtered = arr.filter(w => isMelee ? String(w.range).toLowerCase()==='melee' : String(w.range).toLowerCase()!=='melee');
      if (!filtered.length) throw new Error('No weapons of selected type');
      return filtered.map(w => {
        const skill = numFrom(w.bs_ws || w.BSOrWS) || 4;
        const S = numFrom(w.strength || w.Strength) || 4;
        const AP = parseInt(String(w.ap || w.AP || '0'),10) || 0;
        const attacks = String(w.attacks || w.Attacks || '1');
        const damage = String(w.damage || w.Damage || '1');
        const desc = (w.description || w.Description || '').toString();
        const abilities = parseWeaponAbilities(desc);
        const range = String(w.range || w.Range || '').toString();
        return { name: w.name || w.Name, type: isMelee ? 'melee' : 'ranged', range, attacks, skill, strength: S, ap: AP, damage, desc, abilities };
      });
    }

    async function pickAnyWeapons(fid, uid){
      const resp = await fetch(`/api/${encodeURIComponent(fid)}/${encodeURIComponent(uid)}/weapons`);
  const weapons = await resp.json();
  const arr = Array.isArray(weapons) ? weapons : [];
  return arr.map(w => {
        const isMelee = String(w.range).toLowerCase()==='melee';
        const skill = numFrom(w.bs_ws || w.BSOrWS) || 4;
        const S = numFrom(w.strength || w.Strength) || 4;
        const AP = parseInt(String(w.ap || w.AP || '0'),10) || 0;
        const attacks = String(w.attacks || w.Attacks || '1');
        const damage = String(w.damage || w.Damage || '1');
        const desc = (w.description || w.Description || '').toString();
        const abilities = parseWeaponAbilities(desc);
        const range = String(w.range || w.Range || '').toString();
        return { name: w.name || w.Name, type: isMelee ? 'melee' : 'ranged', range, attacks, skill, strength: S, ap: AP, damage, desc, abilities };
      });
    }

    async function pickWeaponsSafe(fid, uid, preferredType){
      try {
        return await pickWeapons(fid, uid, preferredType);
      } catch {
        try {
          const opposite = preferredType === 'melee' ? 'ranged' : 'melee';
          return await pickWeapons(fid, uid, opposite);
        } catch {
          return await pickAnyWeapons(fid, uid);
        }
      }
    }

    // Fairer AI opponent selection by points across all factions
    async function pickFairOpponentByPoints(myPts){
      if (!myPts || isNaN(myPts) || myPts <= 0) return null;
      // Ensure we have a factions list
      let facs = Array.isArray(factions) && factions.length ? factions : [];
      if (!facs.length) {
        try { facs = await fetch('/api/factions').then(r=>r.json()); } catch { facs = []; }
      }
      if (!facs.length) return null;
      // Fetch units for all factions in parallel
      const settled = await Promise.allSettled(facs.map(f=> {
        const fid = f.id || f.ID;
        return fetch(`/api/${encodeURIComponent(fid)}/units`).then(r=>r.json()).then(list=>({ fid, list }));
      }));
      const entries = [];
      for (const s of settled) {
        if (s.status === 'fulfilled' && s.value && Array.isArray(s.value.list)) {
          const fid = s.value.fid;
          for (const u of s.value.list) {
            const p = parseInt(String(u.points||u.Points||''), 10);
            if (!isNaN(p) && p > 0) entries.push({ fid, unit: u, pts: p });
          }
        }
      }
      if (!entries.length) return null;
      // Try tightening bands and enforce min ratio to avoid heavy mismatches
      const bands = [0.10, 0.15, 0.20, 0.25];
      const minRatio = 0.75; // don't go below 75% of player's points
      const pickFrom = (arr)=>{
        // Sort by absolute distance, then pick among top 3 randomly for variety
        const sorted = arr.slice().sort((a,b)=> Math.abs(a.pts - myPts) - Math.abs(b.pts - myPts));
        const top = sorted.slice(0, Math.min(3, sorted.length));
        return top[Math.floor(Math.random()*top.length)];
      };
      for (const b of bands) {
        let lo = Math.floor(myPts*(1-b));
        const hi = Math.ceil(myPts*(1+b));
        const minLo = Math.floor(myPts*minRatio);
        lo = Math.max(lo, minLo);
        const cands = entries.filter(e => e.pts >= lo && e.pts <= hi);
        if (cands.length) return pickFrom(cands);
      }
      // If still none, pick nearest within broader reasonable bounds
      const broader = entries.filter(e => e.pts >= Math.floor(myPts*minRatio) && e.pts <= Math.ceil(myPts*1.35));
      if (broader.length) return pickFrom(broader);
      // Fallback: absolute nearest overall
      return pickFrom(entries);
    }

  function drawFightPhase(leftDetail, rightDetail, leftW, leftWMax, rightW, rightWMax, res, title='Combat', winnerText=null, nowCtx=null){
      resizeCanvas();
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      ctx.fillStyle = '#0b1016';
      ctx.fillRect(0,0,w,h);
      // Title
      ctx.fillStyle = '#c9a753'; ctx.font='16px system-ui,sans-serif';
      ctx.fillText(title, 12, 22);
      const pad = 12;
      // Columns: left 30%, middle 40%, right 30%
      const colW = [Math.floor((w - pad*4)*0.3), Math.floor((w - pad*4)*0.4), Math.floor((w - pad*4)*0.3)];
      const x0 = pad, x1 = x0 + colW[0] + pad, x2 = x1 + colW[1] + pad;
      const top = 40, boxH = h - top - pad;
      // Panels
      ctx.fillStyle = '#11161f';
      ctx.fillRect(x0, top, colW[0], boxH);
      ctx.fillRect(x1, top, colW[1], boxH);
      ctx.fillRect(x2, top, colW[2], boxH);
  // Left unit
      ctx.fillStyle = '#e5e7eb'; ctx.font='14px system-ui,sans-serif';
  const leftName = leftDetail?.name || 'Player';
  const rightName = rightDetail?.name || 'Opponent';
  const leftPts = (()=>{ const p = leftDetail?.points; return (typeof p === 'number' && p > 0) ? p : null; })();
  const rightPts = (()=>{ const p = rightDetail?.points; return (typeof p === 'number' && p > 0) ? p : null; })();
  const leftLabel = `Player: ${leftName}${leftPts? ` ‚Äî ${leftPts}pts` : ''}`;
  ctx.fillText(leftLabel, x0+8, top+22);
  // Left wounds bar
  let barX = x0+8, barY = top+34, barW = colW[0]-16, barH = 14;
  ctx.fillStyle = '#243042'; ctx.fillRect(barX, barY, barW, barH);
  let frac = Math.max(0, Math.min(1, (leftW||0)/(leftWMax||1)));
  ctx.fillStyle = frac>0.5? '#2ecc71' : frac>0.25? '#f1c40f' : '#e74c3c';
  ctx.fillRect(barX, barY, Math.floor(barW*frac), barH);
  ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
  ctx.fillText(`Wounds: ${leftW}/${leftWMax}`, x0+8, barY+barH+18);
      // Add extra space before stats
      let y = barY+barH+38;
      // Responsive font sizes for mobile
      if (typeof isMobile === 'undefined') {
        var isMobile = window.innerWidth < 600;
      }
      ctx.font = isMobile ? '13px system-ui,sans-serif' : '14px system-ui,sans-serif';
  // Declare ls, lwa, lwr, lwm, usedLeft
  const ls = leftDetail?.stats || {};
  const lwa = leftDetail?.abilities || [];
  const lwr = leftDetail?.weapons?.ranged || [];
  const lwm = leftDetail?.weapons?.melee || [];
  const usedLeft = nowCtx?.usedLeft;
  ctx.fillStyle = '#c9a753'; ctx.font='12px system-ui,sans-serif';
  ctx.fillText(`Stats: T ${ls.T||'-'}  Sv ${ls.Sv? ls.Sv+'+':'-'}  Inv ${ls.InvSv? ls.InvSv+'+':'-'}`, x0+8, y); y+=18;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Abilities:', x0+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const lAbTxt = (lwa && lwa.length) ? `[${lwa.slice(0,4).join(', ')}]` : '[]';
  ctx.fillText(lAbTxt, x0+12, y); y+=16;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Weapons:', x0+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const lwlist = (Array.isArray(usedLeft) ? usedLeft : [...lwr, ...lwm]).slice(0,4);
      lwlist.forEach(wi=>{
        const nm = (wi.name||'Weapon');
        const statsTxt = `A ${wi.attacks||'?'} | Skill ${wi.skill||'?'} | S ${wi.strength||'?'} | AP ${wi.ap||'?'} | D ${wi.damage||'?'}`;
        const rawDesc = (wi.desc||'').replace(/\s+/g,' ');
        const wAbilities = Array.isArray(wi.abilities) ? wi.abilities : parseWeaponAbilities(wi.desc||'');
        const desc = cleanDescriptionAgainstAbilities(rawDesc, wAbilities).slice(0,40);
        // Weapon name and stats
        const base = `‚Ä¢ ${nm} ‚Äî ${statsTxt}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(base, x0+12, y);
        y += 16;
        // Abilities row (gold)
        if (wAbilities.length) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(`[${wAbilities.join(', ')}]`, x0+20, y);
          y += 16;
        }
        // Description row (bluish)
        if (desc) {
          ctx.fillStyle = '#8aa0b8';
          ctx.fillText(`  ${desc}`, x0+20, y);
          y += 16;
        }
      });
  // Right unit
      ctx.fillStyle = '#e5e7eb'; ctx.font='14px system-ui,sans-serif';
  const rightLabel = `Opponent: ${rightName}${rightPts? ` ‚Äî ${rightPts}pts` : ''}`;
  ctx.fillText(rightLabel, x2+8, top+22);
  barX = x2+8; barY = top+34; barW = colW[2]-16; barH = 14;
  ctx.fillStyle = '#243042'; ctx.fillRect(barX, barY, barW, barH);
  frac = Math.max(0, Math.min(1, (rightW||0)/(rightWMax||1)));
  ctx.fillStyle = frac>0.5? '#2ecc71' : frac>0.25? '#f1c40f' : '#e74c3c';
  ctx.fillRect(barX, barY, Math.floor(barW*frac), barH);
  ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
  ctx.fillText(`Wounds: ${rightW}/${rightWMax}`, x2+8, barY+barH+18);
      // Add extra space before stats
      y = barY+barH+38;
      // Responsive font sizes for mobile
      if (typeof isMobile === 'undefined') {
        var isMobile = window.innerWidth < 600;
      }
      ctx.font = isMobile ? '13px system-ui,sans-serif' : '14px system-ui,sans-serif';
  // Declare rs, rwa, rwr, rwm, usedRight
  const rs = rightDetail?.stats || {};
  const rwa = rightDetail?.abilities || [];
  const rwr = rightDetail?.weapons?.ranged || [];
  const rwm = rightDetail?.weapons?.melee || [];
  const usedRight = nowCtx?.usedRight;
  ctx.fillStyle = '#c9a753'; ctx.font='12px system-ui,sans-serif';
  ctx.fillText(`Stats: T ${rs.T||'-'}  Sv ${rs.Sv? rs.Sv+'+':'-'}  Inv ${rs.InvSv? rs.InvSv+'+':'-'}`, x2+8, y); y+=18;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Abilities:', x2+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const rAbTxt = (rwa && rwa.length) ? `[${rwa.slice(0,4).join(', ')}]` : '[]';
  ctx.fillText(rAbTxt, x2+12, y); y+=16;
  ctx.fillStyle = '#c9a753'; ctx.fillText('Weapons:', x2+8, y); y+=16; ctx.fillStyle = '#8aa0b8';
  const rwlist = (Array.isArray(usedRight) ? usedRight : [...rwr, ...rwm]).slice(0,4);
      rwlist.forEach(wi=>{
        const nm = (wi.name||'Weapon');
        const statsTxt = `A ${wi.attacks||'?'} | Skill ${wi.skill||'?'} | S ${wi.strength||'?'} | AP ${wi.ap||'?'} | D ${wi.damage||'?'}`;
        const rawDesc = (wi.desc||'').replace(/\s+/g,' ');
        const wAbilities = Array.isArray(wi.abilities) ? wi.abilities : parseWeaponAbilities(wi.desc||'');
        const desc = cleanDescriptionAgainstAbilities(rawDesc, wAbilities).slice(0,40);
        // Weapon name and stats
        const base = `‚Ä¢ ${nm} ‚Äî ${statsTxt}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(base, x2+12, y);
        y += 16;
        // Abilities row (gold)
        if (wAbilities.length) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(`[${wAbilities.join(', ')}]`, x2+20, y);
          y += 16;
        }
        // Description row (bluish)
        if (desc) {
          ctx.fillStyle = '#8aa0b8';
          ctx.fillText(`  ${desc}`, x2+20, y);
          y += 16;
        }
      });
      // Middle: combat summary (no log spam)
      const resObj = res || {};
      const sp = resObj.subphases || resObj.Subphases || {};
      const tnHit = (sp.hits?.target) ?? (sp.Hits?.Target) ?? null;
      const tnWnd = (sp.wounds?.target) ?? (sp.Wounds?.Target) ?? null;
      const tnSv  = (sp.saves?.target) ?? (sp.Saves?.Target) ?? null;
      const nowA = nowCtx?.attacker || '';
      const nowW = nowCtx?.weaponName || '';
      const nowD = nowCtx?.defender || '';
      const ab  = Array.isArray(nowCtx?.weaponAbilities) && nowCtx.weaponAbilities.length ? ` [${nowCtx.weaponAbilities.join(', ')}]` : '';
      ctx.fillStyle = '#c9a753'; ctx.font='14px system-ui,sans-serif';
      ctx.fillText('Combat', x1+8, top+22);
      ctx.fillStyle = '#8aa0b8'; ctx.font='13px system-ui,sans-serif';
      let yMid = top+44;
      if (nowA || nowW || nowD) {
        const pre = `Now: ${nowA || '‚Äî'} uses ${nowW || '‚Äî'}`;
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(pre, x1+8, yMid);
        let xPos = x1+8 + ctx.measureText(pre).width;
        if (ab) {
          ctx.fillStyle = '#c9a753';
          ctx.fillText(` ${ab}`, xPos, yMid);
          xPos += ctx.measureText(` ${ab}`).width;
        }
        ctx.fillStyle = '#8aa0b8';
        ctx.fillText(` vs ${nowD || '‚Äî'}`, xPos, yMid);
        yMid += 20;
      }
      if (tnHit || tnWnd || tnSv) {
        const svTxt = (tnSv && tnSv !== 7) ? `${tnSv}+` : (tnSv===7 ? '‚Äî' : '');
        const tnLine = `To Hit ${tnHit? tnHit+'+':'?'}, To Wound ${tnWnd? tnWnd+'+':'?'}, Save ${svTxt||'?'}`;
        ctx.fillText(tnLine, x1+8, yMid); yMid += 20;
      }
      const stats = [
        `Attacks: ${resObj.attacks||resObj.Attacks||0}`,
        `Hits: ${resObj.hits||resObj.Hits||0}`,
        `Wounds: ${resObj.wounds||resObj.Wounds||0}`,
        `Saved: ${resObj.saved||resObj.Saved||0}`,
        `Unsaved: ${resObj.unsaved||resObj.Unsaved||0}`,
        `Damage: ${resObj.damage_total||resObj.DamageTotal||0}`,
      ];
      stats.forEach((t,i)=> ctx.fillText(t, x1+8, yMid + i*18));
      // Winner overlay
      if (winnerText) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0,w,h);
        ctx.fillStyle = '#c9a753';
        ctx.font = 'bold 22px system-ui,sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(winnerText, Math.floor(w/2), Math.floor(h/2));
        ctx.restore();
      }
    }
    // Lobby polling
    async function refreshLobby(){
      try {
        const resp = await fetch('/api/lobby');
        const list = await resp.json();
        const wrap = document.getElementById('lobbyList');
  wrap.innerHTML = list.map(e => `
          <div class="col-12 col-md-6 col-lg-4">
            <div class="card bg-dark border-secondary">
              <div class="card-body py-2 d-flex justify-content-between">
    <span class="fw-semibold">${e.name}</span>
    <span class="badge text-bg-secondary">${e.phase || 'idle'}${e.phase==='queue' && e.points ? ` ¬∑ ${e.points}pts` : ''}</span>
              </div>
            </div>
          </div>`).join('');
      } catch {}
    }
    refreshLobby();
    setInterval(refreshLobby, 3000);

    // Action buttons handlers (placeholder wiring)
    function parseSkill(skillStr) {
      if (!skillStr) return 4; // default to 4+
      const match = skillStr.match(/(\d+)/);
      return match ? parseInt(match[1]) : 4;
    }

    function ensureSelection(){
      const sel = window.currentSelection();
      if (!sel.user || sel.user === 'Anonymous') {
        alert('Please choose a username first.');
        return null;
      }
      if (!sel.factionId) { alert('Please select a faction.'); return null; }
      if (!sel.unitId) { alert('Please select a unit.'); return null; }
      return sel;
    }
  const selectionRow = document.querySelector('.selection-BOX_sel_');
  const statsBox = document.getElementById('statsBox');
    function hidePreMatchUI(){
      console.log('hidePreMatchUI called');
      if (selectionRow) {
        selectionRow.classList.add('d-none');
        console.log('Hidden selection row');
      } else {
        console.log('Selection row not found');
      }
      if (statsBox) {
        statsBox.classList.add('d-none');
        console.log('Hidden stats box');
      } else {
        console.log('Stats box not found');
      }
      if (weaponSelectRow) {
        weaponSelectRow.classList.add('d-none');
        console.log('Hidden weapon selection row');
      } else {
        console.log('Weapon select row not found');
      }
      
      // Update lobby status when hiding UI
      const sel = window.currentSelection && window.currentSelection();
      if (sel && sel.user) {
        fetch('/api/lobby/phase', {
          method: 'POST', 
          headers: {'Content-Type': 'application/json'}, 
          body: JSON.stringify({name: sel.user, phase: 'idle'})
        }).catch(()=>{});
      }
    }
    function showPostMatchUI(){
  if (selectionRow) selectionRow.classList.remove('d-none');
  if (statsBox) statsBox.classList.remove('d-none');
  // Show weapon selection after fight
  allowSelectionUI = true;
  if (weaponSelectRow) weaponSelectRow.classList.toggle('d-none', !allowSelectionUI);
  // Re-enable pre-match actions
  try {
    const btnAI = document.getElementById('btnFightAI');
    const btnMM = document.getElementById('btnMatchmake');
    if (btnAI) btnAI.disabled = false;
    if (btnMM) btnMM.disabled = false;
  } catch {}
  
  // Update lobby status back to choosing weapons
  const sel = window.currentSelection && window.currentSelection();
  if (sel && sel.user) {
    fetch('/api/lobby/phase', {
      method: 'POST', 
      headers: {'Content-Type': 'application/json'}, 
      body: JSON.stringify({name: sel.user, phase: 'choosing-weapons'})
    }).catch(()=>{});
  }
    }
  document.getElementById('btnFightAI').addEventListener('click', async ()=>{
      const sel = ensureSelection();
      if (!sel) return;
      console.log('Fight AI with selection:', sel);
  hidePreMatchUI();
  hasFightStarted = true;
  showFightSurface();
  // Hide weapon selection during fight
  if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
      fetch('/api/lobby/phase', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: sel.user, phase: 'vs-ai'})}).catch(()=>{});
  try {
  const [detail] = await Promise.all([
          getUnitDetail(sel.factionId, sel.unitId)
        ]);
        // Build weapon list from selection with fallback
        let weps = [];
        if (sel.weaponType === 'ranged') {
          if (weaponSelection.ranged.size > 0) {
            // Respect selection order: map selected names -> weapon objects
            const names = Array.from(weaponSelection.ranged);
            const byName = new Map(weaponCatalog.ranged.map(w=> [w.name, w]));
            weps = names.map(n=> byName.get(n)).filter(Boolean);
          } else {
            weps = await pickWeapons(sel.factionId, sel.unitId, sel.weaponType);
          }
        } else {
          if (weaponSelection.melee) {
            const m = weaponCatalog.melee.find(w=> w.name === weaponSelection.melee);
            weps = m ? [m] : [];
          }
          if (weps.length === 0) {
            weps = await pickWeapons(sel.factionId, sel.unitId, sel.weaponType);
          }
        }
  // Make sure detail.name remains the unit name; we‚Äôll use sel.user separately
        // Pick fair AI opponent by points across all factions
        const myPts = (()=>{
          const opt = Array.from(unitSelect.options).find(o=> o.value===sel.unitId);
          const v = opt?.getAttribute('data-points') || '';
          const n = parseInt(v,10); return isNaN(n)? null : n;
        })();
        let oppFactionId = sel.factionId;
        let oppUnit = null;
        if (myPts && myPts > 0) {
          const pick = await pickFairOpponentByPoints(myPts);
          if (pick) { oppFactionId = pick.fid; oppUnit = pick.unit; }
        }
        if (!oppUnit) {
          // Fallback: player faction, pick a random unit
          try {
            const oppUnits = await fetch(`/api/${encodeURIComponent(sel.factionId)}/units`).then(r=>r.json());
            if (Array.isArray(oppUnits) && oppUnits.length) {
              oppUnit = oppUnits[Math.floor(Math.random()*oppUnits.length)];
            }
          } catch {}
        }
        const oppUnitId = oppUnit ? (oppUnit.id||oppUnit.ID) : sel.unitId;
        const oppDetail = await getUnitDetail(oppFactionId, oppUnitId);
        // If API detail didn't include points, try to use the selected oppUnit's points
        if (oppDetail && (oppDetail.points == null || Number.isNaN(oppDetail.points))) {
          const rawP = (oppUnit && (oppUnit.points || oppUnit.Points)) || '';
          const np = parseInt(String(rawP), 10);
          if (!Number.isNaN(np)) oppDetail.points = np;
        }
        // Pre-pick opponent weapons: always use default wargear
        const oppAllWeapons = await pickAnyWeapons(oppFactionId, oppUnitId);
        const baseName = (n)=> String(n||'').split(/\s[‚Äì‚Äî-]\s/)[0].trim();
        const uniqByBase = (arr)=>{
          const seen = new Set(); const out = [];
          for (const w of arr) { const b = baseName(w.name); if (!seen.has(b)) { seen.add(b); out.push(w); } }
          return out;
        };
        // Mark default wargear for opponent using its replacement options (same logic as player)
        try {
          const oppOptions = await fetch(`/api/${encodeURIComponent(oppFactionId)}/${encodeURIComponent(oppUnitId)}/options`).then(r=>r.json()).catch(()=>[]);
          // Reuse the same default computation for AI
          const computeDefaultFlagsAI = (weps, opts)=>{
            const norm = (s)=> String(s||'').toLowerCase().replace(/[‚Äì‚Äî]/g,'-').replace(/\s+/g,' ').trim();
            const baseNameOf = (n)=> norm(String(n||'').split(/\s[‚Äì‚Äî-]\s/)[0]);
            const pluralize = (b)=> b.endsWith('s') ? b : `${b}s`;
            const text = norm((Array.isArray(opts)? opts:[]).map(o=> (o.description||o.Description||'')).join(' \n '));
            const names = weps.map(w=> w.name);
            const bases = names.map(n=> baseNameOf(n));
            const plurals = bases.map(b=> pluralize(b));
            const flags = new Map(names.map(n=> [n, true]));
            const replRe = /(replace(?:d)?)[\s\S]*? with [\s\S]*?(?:\.|\n|$)/g;
            let m;
            while ((m = replRe.exec(text))){
              const seg = m[0];
              const wi = seg.indexOf(' with ');
              if (wi < 0) continue;
              const left = seg.slice(0, wi);
              const right = seg.slice(wi + 6);
              for (let i=0;i<names.length;i++){
                const b = bases[i]; const p = plurals[i];
                if (left.includes(b) || left.includes(p)) flags.set(names[i], true);
                if (right.includes(b) || right.includes(p)) flags.set(names[i], false);
              }
            }
            const equipRe = /(equipped with|can be equipped with|can be equipped|can be given)[\s\S]*?(?:\.|\n|$)/g;
            while ((m = equipRe.exec(text))){
              const seg = m[0];
              for (let i=0;i<names.length;i++){
                const b = bases[i]; const p = plurals[i];
                if (seg.includes(b) || seg.includes(p)) flags.set(names[i], false);
              }
            }
            return flags;
          };
          const flagsAI = computeDefaultFlagsAI(oppAllWeapons, oppOptions);
          oppAllWeapons.forEach(w => { w.isStandard = !!flagsAI.get(w.name); });
        } catch { /* ignore, falls back below */ }
        const oppRanged = uniqByBase(oppAllWeapons.filter(w=>w.type==='ranged' && w.isStandard));
        const oppMelee  = uniqByBase(oppAllWeapons.filter(w=>w.type==='melee' && w.isStandard));
  let oppWeps = [];
        if (sel.weaponType === 'ranged') {
          // 40K: models can shoot all their ranged weapons; use all default ranged (deduped by base name)
          oppWeps = oppRanged;
        } else {
          if (oppMelee.length) oppWeps = [oppMelee[0]];
        }
  // No fallback: AI must use default wargear only. If none for the chosen type, it will not fire this round.
  // Fight loop until winner (safety cap rounds=20)
    const matchId = `m_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,7)}`;
        // Show and reset text log panel
        showLogRow();
        if (matchIdLabel) matchIdLabel.textContent = matchId;
  clearTextLog();
    let myHP = detail.stats.W;
        let aiHP = oppDetail.stats.W;
        const aggregate = {Attacks:0, Hits:0, Wounds:0, Saved:0, Unsaved:0, DamageTotal:0, Logs:[]};
    let round = 1;
  const titleBase = `Combat (Match ${matchId})`;
    let stopRequested = false;
    document.getElementById('btnStopFight')?.addEventListener('click', ()=>{ stopRequested = true; }, { once: true });
  while (!stopRequested && myHP > 0 && aiHP > 0) {
          aggregate.Logs.push(`‚Äî Round ${round} ‚Äî`);
          setTextLog(aggregate.Logs);
          // Player volley
          try { aggregate.Logs.push(`Player selected: ${weps.map(w=>w.name).join(', ') || '(none)'}`); setTextLog(aggregate.Logs); } catch {}
          for (const wpn of weps) {
            const payload = {
              attacker: { id: sel.unitId, name: sel.user || 'You', T: detail.stats.T, W: myHP, Sv: detail.stats.Sv, InvSv: detail.stats.InvSv, keywords: (detail.keywords||[]), abilities: (detail.abilities||[]) },
              defender: { id: 'AI', name: 'AI', T: oppDetail.stats.T, W: aiHP, Sv: oppDetail.stats.Sv, InvSv: oppDetail.stats.InvSv, keywords: (oppDetail.keywords||[]), abilities: (oppDetail.abilities||[]) },
      weapon: wpn,
      match_id: matchId,
      meta: { actor: sel.user || 'You', round, step: 1 },
            };
            const resp = await fetch('/api/sim/shoot', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const res = await resp.json();
            // update aggregates
            aggregate.Attacks += (res.attacks||res.Attacks||0);
            aggregate.Hits    += (res.hits||res.Hits||0);
            aggregate.Wounds  += (res.wounds||res.Wounds||0);
            aggregate.Saved   += (res.saved||res.Saved||0);
            aggregate.Unsaved += (res.unsaved||res.Unsaved||0);
            aggregate.DamageTotal += (res.damage_total||res.DamageTotal||0);
            // Track best single volley (by wounds, tie-break by damage)
            {
              const wounds = (res.unsaved||res.Unsaved||0);
              const damage = (res.damage_total||res.DamageTotal||0);
              if (wounds > 0) {
                const prev = aggregate.TopAttack || null;
                const better = !prev || (wounds > (prev.wounds||0)) || (wounds === (prev.wounds||0) && damage > (prev.damage||0));
                if (better) {
                  aggregate.TopAttack = { user: (sel.user||'You'), unit: (detail.name||''), weapon: wpn.name, wounds, damage };
                }
              }
            }
            aiHP = Math.max(0, (res.defender_wounds ?? res.DefenderWounds ?? aiHP));
            const pfx = `${sel.user || 'You'} ${detail.name} ${wpn.name}`;
            (res.logs||res.Logs||[]).forEach(l=> aggregate.Logs.push(`${pfx}: ${l}`));
            if (aiHP <= 0) {
              aggregate.Logs.push('== You win ==');
              drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, 'You win');
              setTextLog(aggregate.Logs);
              try { showWinnerOverlay({ winner: (sel.user||'You'), loser: (oppDetail.name||'AI'), mode: 'AI', matchId }); } catch {}
              stopRequested = true;
              break;
            }
            // Redraw after each weapon volley (player)
            drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, null, { attacker: sel.user || 'You', weaponName: wpn.name, defender: oppDetail.name || 'AI', weaponAbilities: wpn.abilities||[], usedLeft: weps, usedRight: oppWeps });
            setTextLog(aggregate.Logs);
            await sleep(120);
            if (stopRequested) break;
          }
          if (stopRequested || aiHP <= 0) break;
          // Player selection debug removed to keep logs concise
          // AI volley: use chosen opponent weapons
          try { aggregate.Logs.push(`AI selected: ${oppWeps.map(w=>w.name).join(', ') || '(none)'}`); setTextLog(aggregate.Logs); } catch {}
          for (const wpn of oppWeps) {
            const payload = {
              attacker: { id: oppUnitId, name: oppDetail.name || 'AI', T: oppDetail.stats.T, W: aiHP, Sv: oppDetail.stats.Sv, InvSv: oppDetail.stats.InvSv, keywords: (oppDetail.keywords||[]), abilities: (oppDetail.abilities||[]) },
              defender: { id: sel.unitId, name: sel.user || 'You', T: detail.stats.T, W: myHP, Sv: detail.stats.Sv, InvSv: detail.stats.InvSv, keywords: (detail.keywords||[]), abilities: (detail.abilities||[]) },
              weapon: wpn,
              match_id: matchId,
              meta: { actor: 'AI', round, step: 2 },
            };
            const resp = await fetch('/api/sim/shoot', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
            const res = await resp.json();
            myHP = Math.max(0, (res.defender_wounds ?? res.DefenderWounds ?? myHP));
            const pfx = `AI ${oppDetail.name||'Unit'} ${wpn.name}`;
            (res.logs||res.Logs||[]).forEach(l=> aggregate.Logs.push(`${pfx}: ${l}`));
            // Track AI volley as well
            {
              const wounds = (res.unsaved||res.Unsaved||0);
              const damage = (res.damage_total||res.DamageTotal||0);
              if (wounds > 0) {
                const prev = aggregate.TopAttack || null;
                const better = !prev || (wounds > (prev.wounds||0)) || (wounds === (prev.wounds||0) && damage > (prev.damage||0));
                if (better) {
                  aggregate.TopAttack = { user: 'AI', unit: (oppDetail.name||'Unit'), weapon: wpn.name, wounds, damage };
                }
              }
            }
            if (myHP <= 0) {
              aggregate.Logs.push(`== ${oppDetail.name||'AI'} wins ==`);
              drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, `${oppDetail.name||'AI'} wins`);
              setTextLog(aggregate.Logs);
              try { showWinnerOverlay({ winner: (oppDetail.name||'AI'), loser: (sel.user||'You'), mode: 'AI', matchId }); } catch {}
              stopRequested = true;
              break;
            }
            // Redraw after each weapon volley (AI)
            drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase, null, { attacker: oppDetail.name || 'AI', weaponName: wpn.name, defender: sel.user || 'You', weaponAbilities: wpn.abilities||[], usedLeft: weps, usedRight: oppWeps });
      setTextLog(aggregate.Logs);
            await sleep(120);
            if (stopRequested) break;
          }
          round++;
        }
  const winner = stopRequested ? 'Stopped' : myHP <= 0 ? `${oppDetail.name||'AI'} wins` : aiHP <= 0 ? 'You win' : 'Ended';
        aggregate.Logs.push(`== ${winner} ==`);
    drawFightPhase(detail, oppDetail, myHP, detail.stats.W, aiHP, oppDetail.stats.W, aggregate, titleBase);
  setTextLog(aggregate.Logs);
  try {
    if (winner && winner !== 'Ended' && winner !== 'Stopped') {
      const w = winner.replace(' wins','');
      const l = w === (sel.user||'You') ? (oppDetail.name||'AI') : (sel.user||'You');
      showWinnerOverlay({ winner: w, loser: l, mode: 'AI', matchId });
    }
  } catch {}
  // Update statistics after fight
  updateStatistics(aggregate);
  // Keep the canvas visible after the fight ends, including when stopped.
      } catch (e) {
        console.error(e);
  drawSplash();
  hideFightSurface();
  showPostMatchUI();
        alert('Failed to simulate shooting: ' + (e && e.message || e));
      }
    });

  // Statistics update logic
  function updateStatistics(aggregate) {
  // Always show statistics panel after updating
  let statsBoxUpdate = document.getElementById('statsBox');
  if (statsBoxUpdate) statsBoxUpdate.classList.remove('d-none');
  // Highest Damage Attack
  const statBestSave = document.getElementById('statBestSave');
  const statWorstSave = document.getElementById('statWorstSave');
  let topDamage = '‚Äî';
    const bestSave = aggregate.Saved > 0 ? aggregate.Saved : '‚Äî';
    const worstSave = aggregate.Unsaved > 0 ? aggregate.Unsaved : '‚Äî';
  // Find highest damage attack (unsaved only). Prefer structured TopAttack; else parse log.
  let topAttack = aggregate.TopAttack || null;
    let topAttackVal = topAttack ? (topAttack.damage||0) : 0;
  if (!topAttack && Array.isArray(aggregate.Logs)) {
      for (const l of aggregate.Logs) {
        // Only count attacks that caused wounds (unsaved damage)
        // Example log: "User Unit Weapon: ... 3 damage (2 wounds)"
        const m = l.match(/(\w+) (.+?) (.+?):.*?(\d+) damage \((\d+) wounds\)/);
        if (m) {
          const wounds = parseInt(m[5],10);
          if (wounds > 0) {
            const dmg = parseInt(m[4],10);
            if (dmg > topAttackVal) {
              topAttackVal = dmg;
              topAttack = { user: m[1], unit: m[2], weapon: m[3], damage: dmg, wounds };
            }
          }
        }
      }
    }
    const statTopDamageDetails = document.getElementById('statTopDamageDetails');
    let topDamageDetails = '‚Äî';
    if (topAttack) {
      const attacker = topAttack.user || 'Anonymous';
      topDamageDetails = `${attacker}: ${topAttack.unit} - ${topAttack.weapon} ${topAttack.damage} damage (${topAttack.wounds} wounds)`;
    }
  if (statTopDamageDetails) statTopDamageDetails.textContent = topDamageDetails;
  // Set big number to damage from biggest single attack
  topDamage = topAttack ? topAttack.damage : '‚Äî';
    // Build a structured maxAttack object for server-side persistence
    let maxAttack = null;
    if (topAttack) {
      const attacker = topAttack.user || 'Anonymous';
      maxAttack = { username: attacker, unit: topAttack.unit, weapon: topAttack.weapon, wounds: topAttack.wounds, damage: topAttack.damage };
    }
    // Persist to server
    try {
      const username = sessionStorage.getItem('username') || 'Anonymous';
      fetch('/api/stats/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, stats: { topDamage, bestSave, worstSave, topDamageDetails, maxAttack } })
      }).catch(()=>{});
      if (maxAttack) {
        fetch('/api/stats/max-attack/today', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ attack: maxAttack })
        }).then(()=>{
          // Refresh from global so we show today's leader (not just this fight's)
          return fetch('/api/stats/max-attack/today');
    }).then(r=> r && r.ok ? r.json() : null).then(g=>{
          if (g && g.username && g.weapon) {
            const statTopDamageDetails = document.getElementById('statTopDamageDetails');
            const dmg = g.damage || 0;
      const wnd = g.wounds || 0;
      if (statTopDamageDetails) statTopDamageDetails.textContent = `${g.username}: ${g.unit} - ${g.weapon} ${dmg} damage (${wnd} wounds)`;
          }
        }).catch(()=>{});
      }
    } catch {}
  if (statBestSave) statBestSave.textContent = bestSave;
  if (statWorstSave) statWorstSave.textContent = worstSave;
  const statsBox = document.getElementById('statsBox');
  if (statsBox) statsBox.classList.remove('d-none');
  }
    // Matchmaking state
    let matchmakingActive = false;
    let matchmakingInterval = null;
    let currentPvPMatch = null;

    // PvP Match handling
    async function startPvPMatch(match, playerName, unitDetail, unitStats, selectedWeapons) {
      console.log('Starting PvP match:', match);
      // Hide pre-match UI and disable actions to prevent AI fights or changes during PvP
  try { hidePreMatchUI(); } catch {}
  allowSelectionUI = false;
  if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
      try {
        const btnAI = document.getElementById('btnFightAI');
        const btnMM = document.getElementById('btnMatchmake');
        if (btnAI) btnAI.disabled = true;
        if (btnMM) btnMM.disabled = true;
      } catch {}
      // Reflect lobby phase
      try {
        const sel = window.currentSelection && window.currentSelection();
        if (sel && sel.user) {
          fetch('/api/lobby/phase', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: sel.user, phase: 'in-game' }) }).catch(() => {});
        }
      } catch {}
      
      hasFightStarted = true;
      showFightSurface();
      showLogRow();
      
      if (matchIdLabel) matchIdLabel.textContent = match.id;
      clearTextLog();
      
      // Determine if we need to wait for opponent data
      const isPlayer1 = match.player1 === playerName;
      const opponentData = isPlayer1 ? match.player2_data : match.player1_data;
      
      if (!opponentData.ready) {
        // Wait for opponent to join
        setTextLog(['Waiting for opponent to join the match...']);
        
        // Poll for opponent readiness
        const waitForOpponent = async () => {
          try {
            const resp = await fetch(`/api/pvp/match/${match.id}`);
            const updatedMatch = await resp.json();
            
            const updatedOpponentData = isPlayer1 ? updatedMatch.player2_data : updatedMatch.player1_data;
            
            if (updatedOpponentData.ready) {
              // Opponent joined! Start the game
              currentPvPMatch = updatedMatch;
              await runPvPCombat(updatedMatch, playerName, unitDetail, unitStats, selectedWeapons);
            } else {
              // Keep waiting
              setTimeout(waitForOpponent, 2000);
            }
          } catch (error) {
            console.error('Error waiting for opponent:', error);
            alert('Error waiting for opponent. Returning to lobby.');
            showPostMatchUI();
          }
        };
        
        waitForOpponent();
      } else {
        // Both players ready, start immediately
        await runPvPCombat(match, playerName, unitDetail, unitStats, selectedWeapons);
      }
    }

    async function runPvPCombat(match, playerName, unitDetail, unitStats, originalSelectedWeapons) {
      const isPlayer1 = match.player1 === playerName;
      const myData = isPlayer1 ? match.player1_data : match.player2_data;
      const opponentData = isPlayer1 ? match.player2_data : match.player1_data;
      const opponentName = isPlayer1 ? match.player2 : match.player1;
      
      // Use weapons from the match data (from the server)
      const selectedWeapons = myData.weapons;
      console.log('Using weapons from match data:', selectedWeapons);
      
      // Create opponent unit detail from match data
      const opponentDetail = {
        name: opponentName,
        points: null,
        stats: { T: 4, W: opponentData.max_hp, Sv: 3, InvSv: 0 }, // Would come from unit data in full implementation
        abilities: [],
        keywords: [],
        weapons: { ranged: opponentData.weapons.filter(w => w.type === 'ranged'), melee: opponentData.weapons.filter(w => w.type === 'melee') }
      };
      
      const aggregate = {Attacks:0, Hits:0, Wounds:0, Saved:0, Unsaved:0, DamageTotal:0, Logs:[]};
      let myHP = myData.hp;
      let opponentHP = opponentData.hp;
      let round = 1;
      
      const titleBase = `PvP Combat (${match.id})`;
      aggregate.Logs.push(`=== PvP Match: ${playerName} vs ${opponentName} ===`);
      setTextLog(aggregate.Logs);
      
      // Turn-based combat loop
  let gameActive = true;
  let firing = false; // prevent overlapping fire requests
      
      const checkTurn = async () => {
        if (!gameActive) return;
        
        try {
          // Get latest match state
          const resp = await fetch(`/api/pvp/match/${match.id}`);
          const currentMatch = await resp.json();
          
          // Don't take actions until match is active (prevents 400s and error spam)
          if (currentMatch.status !== 'active') {
            const last = aggregate.Logs[aggregate.Logs.length - 1] || '';
            if (!last.includes('Waiting for match to start')) {
              aggregate.Logs.push('Waiting for match to start...');
              setTextLog(aggregate.Logs);
            }
            setTimeout(checkTurn, 1000);
            return;
          }

          // Sync HP from server snapshot every tick (reflect opponent actions)
          try {
            const curMine = isPlayer1 ? currentMatch.player1_data : currentMatch.player2_data;
            const curOpp = isPlayer1 ? currentMatch.player2_data : currentMatch.player1_data;
            myHP = curMine.hp;
            opponentHP = curOpp.hp;
          } catch {}

          if (currentMatch.status === 'finished') {
            // Game over
            gameActive = false;
            const winner = currentMatch.player1_data.hp > 0 ? currentMatch.player1 : currentMatch.player2;
            aggregate.Logs.push(`=== ${winner} wins! ===`);
            
            const winnerText = winner === playerName ? 'You win!' : `${winner} wins!`;
            drawFightPhase(unitDetail, opponentDetail, myHP, unitStats.W, opponentHP, opponentData.max_hp, aggregate, titleBase, winnerText);
            setTextLog(aggregate.Logs);
            
            // Show winner splash
            const loser = winner === currentMatch.player1 ? currentMatch.player2 : currentMatch.player1;
            showWinnerOverlay({ winner, loser, mode: 'PvP', matchId: match.id, subtitle: `${winner} triumphs over ${loser}` });

            // Update statistics
            updateStatistics(aggregate);
            return;
          }
          
          if (currentMatch.turn === playerName) {
            if (firing) { setTimeout(checkTurn, 500); return; }
            // Our turn!
            aggregate.Logs.push(`--- Round ${round} - Your turn ---`);
            setTextLog(aggregate.Logs);
            
            // Fire only one weapon per turn (server enforces turn-by-turn)
            console.log('selectedWeapons array:', selectedWeapons);
            console.log('selectedWeapons.length:', selectedWeapons.length);
            
            // Choose one weapon per turn; rotate through selections deterministically
            if (!Array.isArray(selectedWeapons) || selectedWeapons.length === 0) {
              aggregate.Logs.push('No weapons selected for PvP. Waiting...');
              setTextLog(aggregate.Logs);
              setTimeout(checkTurn, 2000);
              return;
            }
            const i = (round - 1) % selectedWeapons.length;
            const weapon = selectedWeapons[i];
              console.log(`Weapon ${i}:`, weapon);
              
              if (!weapon) {
                console.error(`Weapon at index ${i} is undefined!`);
                aggregate.Logs.push(`Error: Weapon ${i} is undefined`);
                setTextLog(aggregate.Logs);
                // Try again on next tick
                setTimeout(checkTurn, 2000);
                return;
              }
              
              try {
                firing = true;
                const actionResp = await fetch(`/api/pvp/action/${match.id}`, {
                  method: 'POST',
                  headers: {'Content-Type': 'application/json'},
                  body: JSON.stringify({
                    player: playerName,
                    weapon_id: i
                  })
                });
                const weaponName = weapon.Name || weapon.name || 'Unknown Weapon';

                if (!actionResp.ok) {
                  let msg = '';
                  try { const err = await actionResp.json(); msg = err.message || err.error || ''; } catch {}
                  if (!msg) msg = `${actionResp.status} ${actionResp.statusText}`;
                  aggregate.Logs.push(`Error firing ${weaponName}: ${msg}`);
                  setTextLog(aggregate.Logs);
                  // Try again on next tick
                  firing = false;
                  setTimeout(checkTurn, 2000);
                  return;
                }

                const actionResult = await actionResp.json();
                const result = actionResult.result;
                
                // Update aggregates
                aggregate.Attacks += (result.attacks || result.Attacks || 0);
                aggregate.Hits += (result.hits || result.Hits || 0);
                aggregate.Wounds += (result.wounds || result.Wounds || 0);
                aggregate.Saved += (result.saved || result.Saved || 0);
                aggregate.Unsaved += (result.unsaved || result.Unsaved || 0);
                aggregate.DamageTotal += (result.damage_total || result.DamageTotal || 0);
                
                // Update HP
                const updatedMatch = actionResult.match;
                const updatedOpponentData = isPlayer1 ? updatedMatch.player2_data : updatedMatch.player1_data;
                opponentHP = updatedOpponentData.hp;
                
                // Add to log
                const pfx = `${playerName} ${weaponName}`;
                (result.logs || result.Logs || []).forEach(l => aggregate.Logs.push(`${pfx}: ${l}`));
                
                // Update display
                drawFightPhase(unitDetail, opponentDetail, myHP, unitStats.W, opponentHP, opponentData.max_hp, aggregate, titleBase, null, { 
                  attacker: playerName, weaponName: weaponName, defender: opponentName, weaponAbilities: weapon.Abilities || weapon.abilities || [], 
                  usedLeft: selectedWeapons, usedRight: opponentData.weapons 
                });
                setTextLog(aggregate.Logs);
                
                await sleep(120);
                if (updatedMatch.status === 'finished') { gameActive = false; return; }
              } catch (error) {
                console.error('Error firing weapon:', error);
                const weaponName = weapon ? (weapon.Name || weapon.name || 'Unknown') : 'undefined weapon';
                aggregate.Logs.push(`Error firing ${weaponName}`);
                setTextLog(aggregate.Logs);
              } finally { firing = false; }
            
            round++;
            
          } else {
            // Opponent's turn, wait
            aggregate.Logs.push(`--- Round ${round} - ${opponentName}'s turn ---`);
            aggregate.Logs.push('Waiting for opponent...');
            setTextLog(aggregate.Logs);
            
            drawFightPhase(unitDetail, opponentDetail, myHP, unitStats.W, opponentHP, opponentData.max_hp, aggregate, titleBase);
          }
          
          // Continue checking
          setTimeout(checkTurn, 2000);
          
        } catch (error) {
          console.error('Error in turn check:', error);
          gameActive = false;
          alert('Connection error. Returning to lobby.');
          showPostMatchUI();
        }
      };
      
      // Start the turn checking loop
      checkTurn();
    }

    document.getElementById('btnMatchmake').addEventListener('click', async ()=>{
      const sel = ensureSelection();
      if (!sel) return;
      
      const matchmakeBtn = document.getElementById('btnMatchmake');
      const cancelBtn = document.getElementById('btnCancelMatchmake');
      const originalText = matchmakeBtn.textContent;
      
      try {
        console.log('Queue for PVP matchmaking with selection:', sel);
        
  // Update UI for matchmaking
        matchmakeBtn.classList.add('d-none');
        cancelBtn.classList.remove('d-none');
        matchmakingActive = true;
        // Disable actions while queued
        try {
          const btnAI = document.getElementById('btnFightAI');
          if (btnAI) btnAI.disabled = true;
          matchmakeBtn.disabled = true;
        } catch {}
        
        hidePreMatchUI();
  allowSelectionUI = false;
  if (weaponSelectRow) weaponSelectRow.classList.add('d-none');
        // Set phase to queue with points immediately
        try {
          const points = Number((await getUnitDetail(sel.factionId, sel.unitId))?.points) || Number((await getUnitStats(sel.factionId, sel.unitId))?.W) || 0;
          fetch('/api/lobby/phase', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name: sel.user, phase: 'queue', points }) }).catch(()=>{});
        } catch {}
        
        // Get current unit stats and weapons for PvP
        const [unitDetail, unitStats] = await Promise.all([
          getUnitDetail(sel.factionId, sel.unitId),
          getUnitStats(sel.factionId, sel.unitId)
        ]);

        // Prepare weapon data for PvP
        const weaponType = getWeaponType();
        let selectedWeapons = [];
        
        if (weaponType === 'ranged') {
          if (weaponSelection.ranged.size > 0) {
            const names = Array.from(weaponSelection.ranged);
            const byName = new Map(weaponCatalog.ranged.map(w=> [w.name, w]));
            selectedWeapons = names.map(n=> byName.get(n)).filter(Boolean);
          } else {
            selectedWeapons = await pickWeapons(sel.factionId, sel.unitId, weaponType);
          }
        } else {
          if (weaponSelection.melee) {
            const m = weaponCatalog.melee.find(w=> w.name === weaponSelection.melee);
            selectedWeapons = m ? [m] : [];
          }
          if (selectedWeapons.length === 0) {
            selectedWeapons = await pickWeapons(sel.factionId, sel.unitId, weaponType);
          }
        }

        // Convert weapons to API format
        const apiWeapons = selectedWeapons.map(weapon => {
          console.log('Converting weapon:', weapon);
          return {
            Name: weapon.name,
            Type: weaponType,
            Attacks: weapon.A || weapon.attacks || "1",
            Skill: parseSkill(weapon.BS || weapon.WS),
            Strength: parseInt(weapon.S) || 4,
            AP: parseInt(weapon.AP) || 0,
            Damage: weapon.D || weapon.damage || "1",
            Abilities: weapon.abilities || []
          };
        });
        
        console.log('API weapons data:', apiWeapons);
        
        // Submit to PvP matchmaking directly
        const pvpData = {
          name: sel.user,
          faction_id: sel.factionId,
          unit_id: sel.unitId,
          weapons: apiWeapons,
          hp: unitStats.W,
          max_hp: unitStats.W
        };
        
        console.log('PvP data being sent:', pvpData);

        const matchResponse = await fetch('/api/pvp/matchmake', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(pvpData)
        });

        let matchResult;
        if (!matchResponse.ok) {
          // Treat transient/server validation issues as queued to avoid user-facing failure
          try {
            const errText = await matchResponse.text();
            console.warn('PvP API non-OK, falling back to queued:', matchResponse.status, errText);
          } catch {}
          matchResult = { status: 'queued' };
        } else {
          matchResult = await matchResponse.json();
        }
        console.log('Match result:', matchResult);
        
        if (matchResult.status === 'match_created') {
          // Match found immediately!
          currentPvPMatch = matchResult.match;
          matchmakingActive = false;
          
          // Reset UI buttons
          matchmakeBtn.classList.remove('d-none');
          cancelBtn.classList.add('d-none');
          cancelBtn.textContent = 'Cancel Search';
          
          // Start PvP game
          await startPvPMatch(currentPvPMatch, sel.user, unitDetail, unitStats, selectedWeapons);
          
        } else if (matchResult.status === 'existing_match') {
          // Player already has an active match - check if it's valid
          currentPvPMatch = matchResult.match;
          console.log('Found existing match:', currentPvPMatch);
          
          // Check if the opponent is still active in the lobby
          try {
            const lobbyResp = await fetch('/api/lobby');
            const lobby = await lobbyResp.json();
            const opponentName = currentPvPMatch.player1 === sel.user ? currentPvPMatch.player2 : currentPvPMatch.player1;
            const opponent = lobby.find(p => p.name === opponentName);
            
            if (!opponent || opponent.phase === 'idle') {
              // Opponent is not active, this match is abandoned
              console.log('Opponent not active, treating as abandoned match');
              setTextLog(['‚ö†Ô∏è Previous match abandoned', 'Opponent is no longer available.', '', 'Searching for new opponent...']);
              
              // Continue with normal matchmaking flow by falling through to queued logic
              matchResult.status = 'queued';
            } else {
              // Opponent is still active, resume the match
              matchmakingActive = false;
              
              // Reset UI buttons
              matchmakeBtn.classList.remove('d-none');
              cancelBtn.classList.add('d-none');
              cancelBtn.textContent = 'Cancel Search';
              
              console.log('Resuming valid existing match:', currentPvPMatch);
              setTextLog(['üîÑ Resuming existing match', `Opponent: ${opponentName}`, '', 'Preparing for battle...']);
              
              // Resume existing PvP game
              await startPvPMatch(currentPvPMatch, sel.user, unitDetail, unitStats, selectedWeapons);
              return;
            }
          } catch (error) {
            console.error('Error checking opponent status:', error);
            // If we can't check, assume abandoned and continue with new matchmaking
            matchResult.status = 'queued';
          }
        }
        
        if (matchResult.status === 'queued') {
          // Wait for opponent - keep trying PvP matchmaking
          cancelBtn.textContent = 'Cancel Search';
          
          // Show nice timer message in text log
          clearTextLog();
          setTextLog(['üîç Searching for opponent...', 'This may take up to 60 seconds.', '', 'Emperor protects those who wait.']);
          
          // Update status to show player is in PvP queue
          fetch('/api/lobby/phase', {
            method: 'POST', 
            headers: {'Content-Type': 'application/json'}, 
            body: JSON.stringify({name: sel.user, phase: 'queue', points: (Number(unitStats.points)||0)})
          }).catch(()=>{});
          
          let attempts = 0;
          const maxAttempts = 30; // 60 seconds
          
          const checkForMatch = async () => {
            if (!matchmakingActive) return;
            
            try {
              // Try PvP matchmaking again
              const retryResponse = await fetch('/api/pvp/matchmake', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(pvpData)
              });
              
              const retryResult = await retryResponse.json();
              
              if (retryResult.status === 'match_created' || retryResult.status === 'existing_match') {
                // Match found!
                currentPvPMatch = retryResult.match;
                matchmakingActive = false;
                clearInterval(matchmakingInterval);
                
                setTextLog(['‚úÖ Opponent found!', 'Preparing for battle...']);
                
                // Reset UI buttons
                matchmakeBtn.classList.remove('d-none');
                cancelBtn.classList.add('d-none');
                cancelBtn.textContent = 'Cancel Search';
                
                // If this was an existing match from a race-condition, ensure opponent is valid like initial flow
                if (retryResult.status === 'existing_match') {
                  try {
                    const lobbyResp = await fetch('/api/lobby');
                    const lobby = await lobbyResp.json();
                    const opponentName = currentPvPMatch.player1 === sel.user ? currentPvPMatch.player2 : currentPvPMatch.player1;
                    const opponent = lobby.find(p => p.name === opponentName);
                    if (!opponent || opponent.phase === 'idle') {
                      // Opponent not active anymore; fall back to waiting state on next tick
                      matchmakingActive = true;
                      setTextLog(['‚ö†Ô∏è Previous match detected but opponent inactive', 'Continuing search...']);
                      return;
                    }
                  } catch (_) {
                    // If lobby check fails, proceed anyway
                  }
                }
                await startPvPMatch(currentPvPMatch, sel.user, unitDetail, unitStats, selectedWeapons);
                return;
              }
              
              attempts++;
              if (attempts >= maxAttempts) {
                // Timeout
                matchmakingActive = false;
                clearInterval(matchmakingInterval);
                
                // Clean up lobby status
                await fetch('/api/lobby/phase', {
                  method: 'POST',
                  headers: {'Content-Type': 'application/json'},
                  body: JSON.stringify({name: sel.user, phase: 'idle'})
                });
                
                setTextLog(['‚ùå Matchmaking timeout', 'No opponents found after 60 seconds.', '', 'Try again later or fight the AI!']);
                showPostMatchUI();
                matchmakeBtn.classList.remove('d-none');
                cancelBtn.classList.add('d-none');
                cancelBtn.textContent = 'Cancel Search';
                return;
              }
              
              // Update timer message
              const remaining = maxAttempts - attempts;
              const remainingSeconds = remaining * 2;
              setTextLog([
                'üîç Searching for opponent...',
                `‚è∞ ${remainingSeconds} seconds remaining`,
                '',
                'Emperor protects those who wait.',
                '',
                attempts > 10 ? 'üí≠ Perhaps try a different faction?' : 'üéØ Scanning the galaxy for worthy foes...'
              ]);
              
            } catch (error) {
              console.error('Matchmaking check error:', error);
              matchmakingActive = false;
              clearInterval(matchmakingInterval);
              setTextLog(['‚ùå Matchmaking failed', 'Connection error occurred.', '', 'Please try again.']);
              showPostMatchUI();
              matchmakeBtn.classList.remove('d-none');
              cancelBtn.classList.add('d-none');
              cancelBtn.textContent = 'Cancel Search';
            }
          };
          
          // Check every 2 seconds
          matchmakingInterval = setInterval(checkForMatch, 2000);
          checkForMatch(); // Check immediately too
          
        } else {
          throw new Error(matchResult.message || 'Matchmaking failed');
        }
        
      } catch (error) {
        console.error('Failed to join matchmaking:', error);
        setTextLog(['‚ùå Failed to join matchmaking', 'Please try again in a moment.']);
        matchmakingActive = false;
        showPostMatchUI();
        matchmakeBtn.classList.remove('d-none');
        cancelBtn.classList.add('d-none');
      }
    });

    // Cancel matchmaking
    document.getElementById('btnCancelMatchmake').addEventListener('click', async ()=>{
      const sel = window.currentSelection();
      const matchmakeBtn = document.getElementById('btnMatchmake');
      const cancelBtn = document.getElementById('btnCancelMatchmake');
      
      try {
        matchmakingActive = false;
        clearInterval(matchmakingInterval);
        
        // Leave the queue
        await fetch('/api/lobby/phase', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({name: sel.user, phase: 'idle'})
        });
        
        // Show cancellation message
        setTextLog(['üö´ Matchmaking cancelled', 'Returning to weapon selection...', '', 'Ready when you are, warrior.']);
        
        // Reset UI
        showPostMatchUI();
        matchmakeBtn.classList.remove('d-none');
        cancelBtn.classList.add('d-none');
        cancelBtn.textContent = 'Cancel Search';
        
      } catch (error) {
        console.error('Failed to cancel matchmaking:', error);
        // Reset UI anyway
        showPostMatchUI();
        matchmakeBtn.classList.remove('d-none');
        cancelBtn.classList.add('d-none');
        cancelBtn.textContent = 'Cancel Search';
      }
    });
    // Log action buttons
    document.getElementById('btnCopyLog')?.addEventListener('click', copyTextLog);
    document.getElementById('btnDownloadLog')?.addEventListener('click', ()=>{
      const id = (matchIdLabel?.textContent || '').trim() || 'match';
      const txt = textLogEl?.textContent || '';
      download(`${id}.txt`, txt, 'text/plain');
    });
    document.getElementById('btnDownloadJSON')?.addEventListener('click', ()=>{
      const id = (matchIdLabel?.textContent || '').trim();
      if (id && id !== '‚Äî') downloadJSONLog(id);
    });
  </script>
</body>
</html>
